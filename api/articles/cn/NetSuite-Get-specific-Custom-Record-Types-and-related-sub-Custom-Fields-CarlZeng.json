{"title":"NetSuite: Get specific Custom Record Types and related sub Custom Fields-CarlZeng","slug":"cn/NetSuite-Get-specific-Custom-Record-Types-and-related-sub-Custom-Fields-CarlZeng","date":"2023-08-16T01:01:00.000Z","updated":"2023-10-08T13:38:52.658Z","comments":true,"path":"api/articles/cn/NetSuite-Get-specific-Custom-Record-Types-and-related-sub-Custom-Fields-CarlZeng.json","excerpt":"NetSuite: Get specific Custom Record Types and related sub Custom Fields","covers":null,"content":"<p>NetSuite: Get specific Custom Record Types and related sub Custom Fields</p>\n<!-- more -->\n<h1 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h1><p>以前当使用search.create({})来获取数据时，我们需要制定特定的数据返回列；例如：search.createColumn(options)</p>\n<p>而query可以使用 SELECT * FROM 来动态返回所有的数据列（这在有的时候是一个优点），那么如何让search也动态返回所有的数据列呢？</p>\n<p>var arrColFlds &#x3D; query.runSuiteQL({<br>                query: `SELECT CF.ScriptID scriptid<br>                        FROM CustomField CF left join CustomRecordType on CF.RecordType &#x3D; CustomRecordType.internalid Where CustomRecordType.scriptid = ‘CUSTOMRECORD_1’ and CF.ScriptID like ‘CUSTRECORD%’ `<br>            }).asMappedResults();</p>\n<p> 以上这个query就可以返回Record Type为CUSTOMRECORD_1的所有自定义字段。</p>\n<p>如果你需要所有系统中的Custom Record Types</p>\n<p>SELECT<br>    Name,<br>    ScriptID,<br>    InternalID,<br>    Description,<br>    BUILTIN.DF( Owner ) AS Owner,<br>    AllowQuickSearch,<br>    AllowInlineEditing,<br>    AllowAttachments<br>FROM<br>    CustomRecordType<br>ORDER BY<br>    Name</p>\n<p>可以它对应的数据库表：CustomRecordType， 而保存自定义字段的数据库表名：CustomField</p>\n<p>如果你需要所有系统中的Custom Fields</p>\n<p>SELECT<br>    Name,<br>    ScriptID,<br>    Description,<br>    FieldType,<br>    FieldValueType,<br>    FieldValueTypeRecord,<br>    BUILTIN.DF( FieldValueTypeRecord ) AS FieldValueTypeRecordName,<br>    IsMandatory,<br>    IsStored,<br>    IsShowInList,<br>    BUILTIN.DF( Owner ) AS Owner<br>FROM<br>    CustomField</p>\n<h1 id=\"题外话\"><a href=\"#题外话\" class=\"headerlink\" title=\"题外话\"></a>题外话</h1><p>如果是在Client端，又不想使用query的情况下；可以用ajax访问抓取Record Catalog，速度会比较慢，抓取所有的自定义表和详细的子自定义字段。</p>\n<p>var rcEndpoint &#x3D; ‘&#x2F;app&#x2F;recordscatalog&#x2F;rcendpoint.nl’; var recordTypes; var action &#x3D; ‘getRecordTypes’; var data &#x3D; encodeURI( JSON.stringify( { structureType: ‘FLAT’ } ) ); var url &#x3D; rcEndpoint + ‘?action&#x3D;’ + action + ‘&amp;data&#x3D;’ + data; var xhr &#x3D; new XMLHttpRequest();<br>xhr.open( ‘get’, url, false );<br>xhr.send();</p>\n<p>recordTypes = JSON.parse( xhr.response );<br>console.log( JSON.stringify( recordTypes, null, 5 ) ); var schema &#x3D; [];<br>recordTypes.data.forEach( function( recordType ) {</p>\n<pre><code>console.log( &#39;Loading details for record type &#39; + recordType.id + &#39;...&#39; );    action = &#39;getRecordTypeDetail&#39;;\ndata \\= encodeURI( JSON.stringify( &#123; scriptId: recordType.id, detailType: &#39;SS\\_ANAL&#39; &#125; ) ); var url = rcEndpoint + &#39;?action=&#39; + action + &#39;&amp;data=&#39; + data; var xhr = new XMLHttpRequest();\nxhr.open( &#39;get&#39;, url, false );\nxhr.send();\nrecordDetail \\= JSON.parse( xhr.response );    \nschema.push( recordDetail.data );\n</code></pre>\n<p>});<br>console.log( JSON.stringify( schema, null, 5 ) );</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>结合上面的两个query，我们可以把两个表join起来，用来查询特定Record Type的自定义字段：</p>\n<p>var arrColFlds &#x3D; query.runSuiteQL({<br>                query: `SELECT CF.ScriptID scriptid<br>                        FROM CustomField CF left join CustomRecordType on CF.RecordType &#x3D; CustomRecordType.internalid Where CustomRecordType.scriptid &#x3D; ‘CUSTOMRECORD_1’ and CF.ScriptID like ‘CUSTRECORD%’ `<br>            }).asMappedResults();</p>\n","more":"<p>NetSuite: Get specific Custom Record Types and related sub Custom Fields</p>\n<!-- more -->\n<h1 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h1><p>以前当使用search.create({})来获取数据时，我们需要制定特定的数据返回列；例如：search.createColumn(options)</p>\n<p>而query可以使用 SELECT * FROM 来动态返回所有的数据列（这在有的时候是一个优点），那么如何让search也动态返回所有的数据列呢？</p>\n<p>var arrColFlds &#x3D; query.runSuiteQL({<br>                query: `SELECT CF.ScriptID scriptid<br>                        FROM CustomField CF left join CustomRecordType on CF.RecordType &#x3D; CustomRecordType.internalid Where CustomRecordType.scriptid = ‘CUSTOMRECORD_1’ and CF.ScriptID like ‘CUSTRECORD%’ `<br>            }).asMappedResults();</p>\n<p> 以上这个query就可以返回Record Type为CUSTOMRECORD_1的所有自定义字段。</p>\n<p>如果你需要所有系统中的Custom Record Types</p>\n<p>SELECT<br>    Name,<br>    ScriptID,<br>    InternalID,<br>    Description,<br>    BUILTIN.DF( Owner ) AS Owner,<br>    AllowQuickSearch,<br>    AllowInlineEditing,<br>    AllowAttachments<br>FROM<br>    CustomRecordType<br>ORDER BY<br>    Name</p>\n<p>可以它对应的数据库表：CustomRecordType， 而保存自定义字段的数据库表名：CustomField</p>\n<p>如果你需要所有系统中的Custom Fields</p>\n<p>SELECT<br>    Name,<br>    ScriptID,<br>    Description,<br>    FieldType,<br>    FieldValueType,<br>    FieldValueTypeRecord,<br>    BUILTIN.DF( FieldValueTypeRecord ) AS FieldValueTypeRecordName,<br>    IsMandatory,<br>    IsStored,<br>    IsShowInList,<br>    BUILTIN.DF( Owner ) AS Owner<br>FROM<br>    CustomField</p>\n<h1 id=\"题外话\"><a href=\"#题外话\" class=\"headerlink\" title=\"题外话\"></a>题外话</h1><p>如果是在Client端，又不想使用query的情况下；可以用ajax访问抓取Record Catalog，速度会比较慢，抓取所有的自定义表和详细的子自定义字段。</p>\n<p>var rcEndpoint &#x3D; ‘&#x2F;app&#x2F;recordscatalog&#x2F;rcendpoint.nl’; var recordTypes; var action &#x3D; ‘getRecordTypes’; var data &#x3D; encodeURI( JSON.stringify( { structureType: ‘FLAT’ } ) ); var url &#x3D; rcEndpoint + ‘?action&#x3D;’ + action + ‘&amp;data&#x3D;’ + data; var xhr &#x3D; new XMLHttpRequest();<br>xhr.open( ‘get’, url, false );<br>xhr.send();</p>\n<p>recordTypes = JSON.parse( xhr.response );<br>console.log( JSON.stringify( recordTypes, null, 5 ) ); var schema &#x3D; [];<br>recordTypes.data.forEach( function( recordType ) {</p>\n<pre><code>console.log( &#39;Loading details for record type &#39; + recordType.id + &#39;...&#39; );    action = &#39;getRecordTypeDetail&#39;;\ndata \\= encodeURI( JSON.stringify( &#123; scriptId: recordType.id, detailType: &#39;SS\\_ANAL&#39; &#125; ) ); var url = rcEndpoint + &#39;?action=&#39; + action + &#39;&amp;data=&#39; + data; var xhr = new XMLHttpRequest();\nxhr.open( &#39;get&#39;, url, false );\nxhr.send();\nrecordDetail \\= JSON.parse( xhr.response );    \nschema.push( recordDetail.data );\n</code></pre>\n<p>});<br>console.log( JSON.stringify( schema, null, 5 ) );</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>结合上面的两个query，我们可以把两个表join起来，用来查询特定Record Type的自定义字段：</p>\n<p>var arrColFlds &#x3D; query.runSuiteQL({<br>                query: `SELECT CF.ScriptID scriptid<br>                        FROM CustomField CF left join CustomRecordType on CF.RecordType &#x3D; CustomRecordType.internalid Where CustomRecordType.scriptid &#x3D; ‘CUSTOMRECORD_1’ and CF.ScriptID like ‘CUSTRECORD%’ `<br>            }).asMappedResults();</p>\n","categories":[{"name":"NetSuite","path":"api/categories/NetSuite.json"}],"tags":[{"name":"NetSuite","path":"api/tags/NetSuite.json"}]}
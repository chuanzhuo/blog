{"title":"浅谈javascript函数劫持[转载]-CarlZeng","slug":"cn/浅谈javascript函数劫持-转载-CarlZeng","date":"2009-11-11T06:31:00.000Z","updated":"2023-10-02T02:27:29.007Z","comments":true,"path":"api/articles/cn/浅谈javascript函数劫持-转载-CarlZeng.json","excerpt":"一篇非常好的javascript Function应用文章。原文地址： http://www.xfocus.net/articles/200712/963.html-----------------------------------------------------------------------------------------------一、概述javascri...","covers":null,"content":"<p>一篇非常好的javascript Function应用文章。 原文地址： <a href=\"http://www.xfocus.net/articles/200712/963.html\">http://www.xfocus.net/articles/200712/963.html</a> ———————————————————————————————– 一、概述 javascri…</p>\n<!-- more -->\n<p>一篇非常好的javascript Function应用文章。<br>原文地址： <a href=\"http://www.xfocus.net/articles/200712/963.html\">http://www.xfocus.net/articles/200712/963.html</a>  </p>\n<p>-———————————————————————————————-  </p>\n<p><strong>一、概述</strong>  </p>\n<p>javascript函数劫持，也就是老外提到的javascript hijacking技术。最早还是和剑心同学讨论问题时偶然看到的一段代码，大概这样写的：<br>window.alert &#x3D; function(s) {};<br>觉得这种用法很巧妙新颖，和API Hook异曲同工，索性称之为javascript function hook，也就是函数劫持。通过替换js函数的实现来达到劫持这个函数调用的目的，一个完整的hook alert函数例子如下：  </p>\n<!--1.htm-->  \n<script type=\"text/javascript\">  \n<!--  \nvar \\_alert = alert;  \nwindow.alert = function(s) {  \nif (confirm(\"是否要弹框框，内容是\\\\\"\" + s + \"\\\\\"？\")) {  \n\\_alert(s);  \n}  \n}  \n//-->  \n</script>  \n<html>  \n<body>  \n<input type=\"button\" onclick=\"javascript: alert(Hello World!)\" value=\"test\" />  \n</body>  \n</html>  \n\n  \n  \n<p>搞过API Hook的同学们看到这个代码一定会心的一笑，先保存原函数实现，然后替换为我们自己的函数实现，添加我们自己的处理逻辑后最终再调用原来的函数实现，这样这个alert函数就被我们劫持了。原理非常简单，下面举些典型的应用来看看我们能利用它来做些什么。  </p>\n<p><strong>二、应用举例</strong>  </p>\n<p>1. 实现一个简易的javascript debugger，这里说是debugger比较标题党，其实只是有点类似于debugger的功能，主要利用js函数劫持来实现函数的break point，来看看个简单的例子：  </p>\n<script type=\"text/javascript\">  \n<!--  \nvar \\_eval = eval;  \neval = function(s) {  \nif (confirm(\"eval被调用\\\\n\\\\n调用函数\\\\n\" + eval.caller + \"\\\\n\\\\n调用参数\\\\n\" + s)) {  \n\\_eval(s);  \n}  \n}  \n//-->  \n</script>  \n<html>  \n<head>  \n</head>  \n<body>  \n<script type=\"text/javascript\">  \n<!--  \nfunction test() {  \nvar a = \"alert(1)\";  \neval(a);  \n}  \n  \n<p>function t() {<br>test();<br>}  </p>\n<p>t();<br>&#x2F;&#x2F;–&gt;<br></script>  </p>\n</body>  \n</html>  \n\n  \n  \n<p>通过js函数劫持中断函数执行，并显示参数和函数调用者代码，来看一个完整例子的效果：  </p>\n<p>&gt;help<br>debug commands:  </p>\n<p>bp <function name> - set a breakpoint on a function, e.g. “bp window.alert”.<br>bl - list all breakpoints.<br>bc <breakpoint number> - remove a breakpoint by specified number, e.g. “bc 0”.<br>help - help information.  </p>\n<p>&gt;bp window.alert<br>* breakpoint on function “window.alert” added successfully.  </p>\n<p>&gt;bl<br>* 1 breakpoints:<br>0 - window.alert  </p>\n<p>&gt;bc 0<br>* breakpoint on function “window.alert” deleted successfully.  </p>\n<p>这里演示设置断点，察看断点和删除断点，完整代码在本文附录[1]给出。  </p>\n<p>2. 设置陷阱实时捕捉跨站测试者，搞跨站的人总习惯用alert来确认是否存在跨站，如果你要监控是否有人在测试你的网站xss的话，可以在你要监控的页面里hook alert函数，记录alert调用情况：  </p>\n<script type=\"text/javascript\">  \n<!--  \nfunction log(s) {  \nvar img = new Image();  \nimg.style.width = img.style.height = 0;  \nimg.src = \"[http://yousite.com/log.php?caller=\"](http://yousite.com/log.php?caller=\") + encodeURIComponent(s);  \n}  \n  \nvar \\_alert = alert;  \nwindow.alert = function(s) {  \nlog(alert.caller);  \n\\_alert(s);  \n}  \n//-->  \n</script>  \n\n<p>当然，你这个函数要加到页面的最开始，而且还要比较隐蔽一些，赫赫，你甚至可以使alert不弹框或者弹个警告框，让测试者抓狂一把。  </p>\n<p>3. 实现DOM XSS自动化扫描，目前一般的XSS自动化扫描的方法是从http返回结果中搜索特征来确定是否存在漏洞，但是这种方法不适用于扫描DOM XSS，因为DOM XSS是由客户端脚本造成的，比如前段时间剑心发现的google的跨站(见附录[2])原理如下：  </p>\n<p>document.write(document.location.hash);  </p>\n<p>这样的跨站无法反映在http response里，所以传统扫描方法没法扫描出来。但是如果你从上个例子里受到启发的话，一定会想到设置陷阱的办法，DOM XSS最终导致alert被执行，所以我们hook alert函数设置陷阱，如果XSS成功则会去调用alert函数，触发我们的陷阱记录结果，这样就可以实现DOM XSS的自动化扫描，陷阱代码类似于上面。  </p>\n<p>4. 灵活的使用js劫持辅助你的页面代码分析工作，比如分析网页木马时，经常会有通过eval或者document.write来进行加密的情况，于是我们编写段hook eval和document.write的小工具，辅助解密：  </p>\n<script type=\"text/javascript\">  \n<!--  \nvar \\_eval = eval;  \neval = window.execScript = window.document.write = window.document.writeln = function(s) {  \ndocument.getElementById(\"output\").value = s;  \n}  \n//-->  \n</script>  \n<html>  \n<body>  \ninput:  \n<!--<textarea id=\"input\" cols=\"80\" rows=\"10\"></textarea>-->  \n<input type=\"button\" onclick=\"javascript: \\_eval(document.getElementById(input).value);\" value=\"decode\" />  \n<br />  \noutput:  \n<!--<textarea id=\"output\" cols=\"80\" rows=\"10\"></textarea>-->  \n</body>  \n</html>  \n\n  \n  \n<p>在input框里输入加密的代码：  </p>\n<p>eval(unescape(“%61%6C%65%72%74%28%31%29%3B”));  </p>\n<p>在output框里输出解码后的代码：  </p>\n<p>alert(1);  </p>\n<p>当然你还能想到更多的灵活应用：）  </p>\n<p><strong>三、反劫持</strong>  </p>\n<p>谈到劫持也就必然要谈谈反劫持的话题，假设你要写一个健壮的xss playload，就需要考虑反劫持，有两个问题要解决：  </p>\n<p>如何判断是否被劫持了？<br>如果发现被劫持了，如何反劫持？  </p>\n<p>1. 判断某个函数是否被劫持，这个好办，写个小程序对比一下一个函数被hook前后，有什么差别：  </p>\n<!--<textarea id=\"tb1\" cols=\"80\" rows=\"8\"></textarea>-->  \n<script type=\"text/javascript\">  \n<!--  \ndocument.getElementById(\"tb1\").value = eval + \"\\\\n\";  \nvar \\_eval = eval;  \neval = function(s) {  \nalert(s);  \n\\_eval(s);  \n}  \ndocument.getElementById(\"tb1\").value += eval;  \n//-->  \n</script>  \n\n<p>结果：  </p>\n<p>function eval() {<br>[native code]<br>}  </p>\n<p>function(s) {<br>alert(s);<br>_eval(s);<br>}  </p>\n<p>我们发现那些内置函数是[native code]，而自定义的则是具体的函数定义，用这个特征就可以简单的检测函数是否被劫持：  </p>\n<p>function checkHook(proc) {<br>if (proc.toString().indexOf(“[native code]“) &gt; 0) {<br>return false;<br>} else {<br>return true;<br>}<br>}  </p>\n<p>2. 如何反劫持，第一个想法就是恢复被劫持的函数，如果劫持的人把原函数保存在某个变量里那还好办，直接调用原函数就可以了，但是劫持者自己也没保存副本怎么办，只能自己创建个新的环境，然后用新环境里的干净的函数来恢复我们这里被hook了的，怎么创建新环境？整个新的iframe好了，里面就是个全新的环境。ok，动手吧：  </p>\n<p>function unHook(proc) {<br>var f &#x3D; document.createElement(“iframe”);<br>f.style.border &#x3D; “0”;<br>f.style.width &#x3D; “0”;<br>f.style.height &#x3D; “0”;<br>document.body.appendChild(f);  </p>\n<p>var d &#x3D; f.contentWindow.document;<br>d.write(“&lt;script type&#x3D;\\“text&#x2F;javascript\\“&gt;window.parent.escape &#x3D; escape;&lt;\\&#x2F;script&gt;”);<br>d.close();<br>}  </p>\n<p>综合1、2节，整个测试代码如下：  </p>\n<!--antihook.htm-->  \n<script type=\"text/javascript\">  \n<!--  \nescape = function(s) {  \nreturn s;  \n}  \n//-->  \n</script>  \n<html>  \n<body>  \n<input type=\"button\" onclick=\"javascript: test();\" value=\"test\" />  \n<script type=\"text/javascript\">  \n<!--  \nfunction test() {  \nalert(escape(\"s y\"));  \n  \n<p>if (checkHook(escape)) {<br>unHook(escape);<br>}  </p>\n<p>alert(escape(“s y”));<br>}  </p>\n<p>function checkHook(proc) {<br>if (proc.toString().indexOf(“[native code]“) &gt; 0) {<br>return false;<br>} else {<br>return true;<br>}<br>}  </p>\n<p>function unHook(proc) {<br>var f &#x3D; document.createElement(“iframe”);<br>f.style.border &#x3D; “0”;<br>f.style.width &#x3D; “0”;<br>f.style.height &#x3D; “0”;<br>document.body.appendChild(f);  </p>\n<p>var d &#x3D; f.contentWindow.document;<br>d.write(“&lt;script type&#x3D;\\“text&#x2F;javascript\\“&gt;window.parent.escape &#x3D; escape;&lt;\\&#x2F;script&gt;”);<br>d.close();<br>}<br>&#x2F;&#x2F;–&gt;<br></script>  </p>\n</body>  \n</html>  \n\n  \n  \n<p>3. 不是上面两个问题都解决了么，为什么要有第3节？因为那不是个最好的解决办法，既然我们可以创建全新的iframe，何不把代码直接放到全新iframe 里执行呢，这样做的话绿色环保，既不用考虑当前context里的hook问题，也不用改动当前context，不会影响本身的程序执行。给出两个比较通用点的函数：  </p>\n<p>function createIframe(w) {<br>var d &#x3D; w.document;<br>var newIframe &#x3D; d.createElement(“iframe”);<br>newIframe.style.width &#x3D; 0;<br>newIframe.style.height &#x3D; 0;<br>d.body.appendChild(newIframe);<br>newIframe.contentWindow.document.write(“<html><body></body></html>“);<br>return newIframe;<br>}  </p>\n<p>function injectScriptIntoIframe(f, proc) {<br>var d &#x3D; f.contentWindow.document;<br>var s &#x3D; “<script>\\n(\" + proc.toString() + \")();\\n</script>“;<br>d.write(s);<br>}  </p>\n<p>把你的payload封装进一个函数，然后调用这两个方法来在iframe里执行：  </p>\n<p>function payload() {<br>&#x2F;&#x2F; your code goes here<br>}  </p>\n<p>var f &#x3D; createIframe(top);<br>injectScriptIntoIframe(f, payload);  </p>\n<p><strong>四、最后</strong>  </p>\n<p>由于国内很少有见文章提及这个东西，所以才草成这篇，希望能够抛砖引玉。由于本人水平有限，难免有错误或者疏漏之处请谅解，没有说清楚的地方，欢迎和我交流。  </p>\n<p>还有就是一些不得不感谢的人，感谢剑心一直以来毫无保留的交流，感谢黑锅多次鼓励我把自己的心得体会写成文字，感谢幻影所有的朋友们、B.C.T的朋友们以及群里那帮经常一起扯淡的朋友们。  </p>\n<p>广告一下，没法幻影blog的朋友，可以添加hosts来突破：<br>72.14.219.190 pstgroup.blogspot.com  </p>\n<p><strong>五、附录</strong>  </p>\n<p>[1] 简易的javascript inline debugger代码  </p>\n<!--test.htm-->  \n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"[http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"><p>](<a href=\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd%22%3E\">http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;</a>)  </p>\n<html xmlns=\"[http://www.w3.org/1999/xhtml\">](http://www.w3.org/1999/xhtml\">)  \n<head><title>Javascript Inline Debugger</title></head>  \n<body>  \n<script language=\"javascript\" type=\"text/javascript\" src=\"js\\_inline\\_debugger.js\"></script>  \n<input type=\"button\" value=\"hahaha\" onclick=\"javascript: alert(this.value);\" style=\"margin-left: 300px;\" />  \n</body>  \n</html>  \n  \n  \n<p>&#x2F;*<br>FileName: js_inline_debugger.js<br>Author: luoluo<br>Contact: luoluonet_at_yahoo.cn<br>Date: 2007-6-27<br>Version: 0.1<br>Usage:<br><!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"[http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">](<a href=\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd%22%3E\">http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;</a>)  </p>\n<html xmlns=\"[http://www.w3.org/1999/xhtml\">](http://www.w3.org/1999/xhtml\">)  \n<head>  \n</head>  \n<body>  \n<script language=\"javascript\" type=\"text/javascript\" src=\"js\\_inline\\_debugger.js\"></script>  \n</body>  \n</html>  \nInstruction:  \nIt is a simple javascript inline debugger. You must add xhtml1-transitional dtd to your  \nhtml document if you wanna to use the script.  \n\\*/  \n  \n<p>&#x2F;&#x2F;————————————————————————–&#x2F;&#x2F;<br>&#x2F;&#x2F; 公用的函数<br>&#x2F;&#x2F;————————————————————————–&#x2F;&#x2F;<br>&#x2F;&#x2F; 判断是否是IE<br>function isIE() {<br>return document.all &amp;&amp; window.external;<br>}  </p>\n<p>&#x2F;&#x2F; 去除字符串两边的空格<br>String.prototype.trim &#x3D; function() {<br>var re &#x3D; &#x2F;(^\\s*)|(\\s*)$&#x2F;g;<br>return this.replace(re, “”);<br>}  </p>\n<p>&#x2F;&#x2F; 删除数组中某个元素<br>Array.prototype.remove &#x3D; function(i) {<br>var o &#x3D; this[i];<br>for (var j &#x3D; i; j &lt; this.length - 1; j ++) {<br>this[j] &#x3D; this[j + 1];<br>}<br>-- this.length;<br>return o;<br>}  </p>\n<p>&#x2F;&#x2F; 判断一个数组中是否存在相同的元素<br>Array.prototype.search &#x3D; function(o) {<br>for (var i &#x3D; 0; i &lt; this.length; i ++) {<br>if (this[i] &#x3D;&#x3D; o) {<br>return i;<br>}<br>}  </p>\n<p>return -1;<br>}  </p>\n<p>&#x2F;&#x2F; html编码<br>function htmlEncode(s) {<br>s &#x3D; s.replace(&#x2F;&amp;&#x2F;g, “&amp;”);<br>s &#x3D; s.replace(&#x2F;&lt;&#x2F;g, “&lt;”);<br>s &#x3D; s.replace(&#x2F;&gt;&#x2F;g, “&gt;”);<br>s &#x3D; s.replace(&#x2F;\\“&#x2F;g, “””);<br>s &#x3D; s.replace(&#x2F;\\&#x2F;g, “””);  </p>\n<p>return s;<br>}  </p>\n<p>&#x2F;&#x2F; js编码<br>function jsEncode(s) {<br>s &#x3D; s.replace(&#x2F;\\\\&#x2F;g, “\\\\\\\\“);<br>s &#x3D; s.replace(&#x2F;\\n&#x2F;g, “\\\\n”);<br>s &#x3D; s.replace(&#x2F;\\“&#x2F;g, “\\\\\\“”);<br>s &#x3D; s.replace(&#x2F;\\&#x2F;g, “\\\\\\“);<br>return s;<br>}  </p>\n<p>&#x2F;&#x2F;————————————————————–&#x2F;&#x2F;<br>&#x2F;&#x2F; 命令行窗口工具<br>&#x2F;&#x2F;————————————————————–&#x2F;&#x2F;<br>function Console(parentNode, processInputProc) {<br>&#x2F;&#x2F; 窗口<br>var panel &#x3D; document.createElement(“div”);<br>panel.style.width &#x3D; “250px”;<br>panel.style.height &#x3D; “250px”;<br>panel.style.borderColor &#x3D; “#666666”;<br>panel.style.borderWidth &#x3D; “1px”;<br>panel.style.backgroundColor &#x3D; “#ffffff”;<br>panel.style.borderStyle &#x3D; “solid”;<br>panel.style.position &#x3D; “absolute”;<br>panel.style.zIndex &#x3D; 100;<br>parentNode.appendChild(panel);  </p>\n<p>&#x2F;&#x2F; 标题栏<br>var title &#x3D; document.createElement(“div”);<br>title.style.width &#x3D; “250px”;<br>title.style.height &#x3D; “15px”;<br>title.style.backgroundColor &#x3D; “#dddddd”;<br>title.style.fontSize &#x3D; “12px”;<br>title.style.fontFamily &#x3D; “verdana,tahoma”;<br>panel.appendChild(title);  </p>\n<p>&#x2F;&#x2F; 标题栏拖动窗口功能<br>var isDragging &#x3D; false;<br>var startPos &#x3D; new Position(panel.offsetLeft, panel.offsetTop);<br>var startMousePos &#x3D; new Position(0, 0);  </p>\n<p>title.onmouseover &#x3D; function(evt) {<br>this.style.cursor &#x3D; “pointer”;<br>}  </p>\n<p>title.onmousedown &#x3D; function(evt) {<br>if (isDragging &#x3D;&#x3D; true) {<br>return;<br>}  </p>\n<p>var event &#x3D; evt || window.event;<br>startMousePos.x &#x3D; event.clientX;<br>startMousePos.y &#x3D; event.clientY;<br>isDragging &#x3D; true;<br>}  </p>\n<p>title.onmousemove &#x3D; function(evt) {<br>if (isDragging &#x3D;&#x3D; false) {<br>return;<br>}  </p>\n<p>activateWindow();<br>var event &#x3D; evt || window.event;<br>panel.style.left &#x3D; (event.clientX - startMousePos.x) + startPos.x + “px”;<br>panel.style.top &#x3D; (event.clientY - startMousePos.y) + startPos.y + “px”;<br>}  </p>\n<p>title.onmouseup &#x3D; function(evt) {<br>if (isDragging &#x3D;&#x3D; false) {<br>return;<br>}  </p>\n<p>var event &#x3D; evt || window.event;<br>startPos.x &#x3D; (event.clientX - startMousePos.x) + startPos.x;<br>panel.style.left &#x3D; startPos.x + “px”;<br>startPos.y &#x3D; (event.clientY - startMousePos.y) + startPos.y;<br>panel.style.top &#x3D; startPos.y + “px”;<br>isDragging &#x3D; false;<br>}  </p>\n<p>&#x2F;&#x2F; 关闭窗口功能<br>var closeButton &#x3D; document.createElement(“div”);<br>closeButton.style.width &#x3D; “13px”;<br>closeButton.style.height &#x3D; “13px”;<br>closeButton.style.backgroundColor &#x3D; “#ffffff”;<br>closeButton.style.styleFloat &#x3D; closeButton.style.cssFloat &#x3D; “left”;<br>closeButton.style.fontSize &#x3D; “12px”;<br>closeButton.style.borderWidth &#x3D; “1px”;<br>closeButton.style.borderColor &#x3D; “#999999”;<br>closeButton.style.borderStyle &#x3D; “solid”;<br>closeButton.style.paddingButton &#x3D; “2px”;<br>closeButton.innerHTML &#x3D; “&lt;div style&#x3D;\\“margin-top: -2px;margin-left: 3px;\\“&gt;x</div>“;<br>title.appendChild(closeButton);  </p>\n<p>var isVisible &#x3D; true;  </p>\n<p>&#x2F;&#x2F; 窗口关闭<br>closeButton.onclick &#x3D; function(evt) {<br>isVisible &#x3D; false;<br>panel.style.display &#x3D; “none”;<br>}  </p>\n<p>&#x2F;&#x2F; 标题栏文字<br>var titleLabel &#x3D; document.createElement(“div”);<br>titleLabel.style.height &#x3D; “14px”;<br>titleLabel.style.width &#x3D; “200px”;<br>titleLabel.style.fontSize &#x3D; “11px”;<br>titleLabel.style.color &#x3D; “#ffffff”;<br>titleLabel.style.styleFloat &#x3D; titleLabel.style.cssFloat &#x3D; “left”;<br>titleLabel.style.fontFamily &#x3D; “verdana,tahoma”;<br>titleLabel.innerHTML &#x3D; “Javascript Inline Debugger”;<br>&#x2F;&#x2F;titleLabel.style.marginTop &#x3D; isIE() ? -14 : “-14px”;<br>titleLabel.style.marginLeft &#x3D; isIE() ? 18 : “18px”;<br>title.appendChild(titleLabel);  </p>\n<p>&#x2F;&#x2F; 中间的显示部分<br>var showPanel &#x3D; document.createElement(“div”);<br>showPanel.style.width &#x3D; “250px”;<br>showPanel.style.height &#x3D; isIE() ? “221px” : “219px”;<br>showPanel.style.fontSize &#x3D; “11px”;<br>showPanel.style.padding &#x3D; “0”;<br>showPanel.style.margin &#x3D; “0”;<br>showPanel.style.overflow &#x3D; “auto”;<br>showPanel.style.marginTop &#x3D; isIE() ? -1 : “0”;<br>panel.appendChild(showPanel);  </p>\n<p>&#x2F;&#x2F; 命令输入框<br>var cmdArea &#x3D; document.createElement(“div”);<br>panel.appendChild(cmdArea);  </p>\n<p>var cmdTextbox &#x3D; document.createElement(“input”);<br>cmdTextbox.type &#x3D; “text”;<br>cmdTextbox.style.width &#x3D; “250px”;<br>cmdTextbox.style.height &#x3D; “12px”;<br>cmdTextbox.style.fontSize &#x3D; “12px”;<br>cmdTextbox.style.padding &#x3D; “0”;<br>cmdTextbox.style.margin &#x3D; “0”;<br>cmdTextbox.style.marginTop &#x3D; isIE() ? -2 : “0”;<br>cmdTextbox.style.borderWidth &#x3D; “0”;<br>cmdTextbox.style.borderTopWidth &#x3D; “1px”;<br>cmdTextbox.style.paddingTop &#x3D; “2px”;<br>cmdArea.appendChild(cmdTextbox);  </p>\n<p>&#x2F;&#x2F; 窗口激活或者不激活<br>var isActive &#x3D; false;  </p>\n<p>&#x2F;&#x2F; 激活窗口<br>var activateWindow &#x3D; function() {<br>if (! isVisible) {<br>return;<br>}  </p>\n<p>if (isActive) {<br>return;<br>}  </p>\n<p>cmdTextbox.focus();<br>title.style.backgroundColor &#x3D; “#015DF4”;<br>isActive &#x3D; true;<br>}  </p>\n<p>panel.onclick &#x3D; activateWindow;  </p>\n<p>&#x2F;&#x2F; 不激活窗口<br>var deactivateWindow &#x3D; function() {<br>if (! isVisible) {<br>return;<br>}  </p>\n<p>if (! isActive) {<br>return;<br>}  </p>\n<p>title.style.backgroundColor &#x3D; “#cccccc”;<br>isActive &#x3D; false;<br>}  </p>\n<p>cmdTextbox.onfocus &#x3D; activateWindow;<br>cmdTextbox.onblur &#x3D; deactivateWindow;  </p>\n<p>&#x2F;&#x2F; 输出函数<br>var dbgPrint &#x3D; function(s) {<br>showPanel.innerHTML +&#x3D; htmlEncode(s).replace(&#x2F;\\n|(\\r\\n)&#x2F;g, “<br />“);  </p>\n<p>if (parseInt(showPanel.scrollHeight) &gt; parseInt(showPanel.style.height)) {<br>showPanel.scrollTop +&#x3D; parseInt(showPanel.scrollHeight) - parseInt(showPanel.style.height);<br>}<br>}  </p>\n<p>&#x2F;&#x2F; 调用输入处理回调函数<br>cmdTextbox.onkeydown &#x3D; function(evt) {<br>var event &#x3D; evt || window.event;  </p>\n<p>if (event.keyCode &#x3D;&#x3D; 0x0d) {<br>processInputProc(this.value, dbgPrint);<br>this.value &#x3D; “”;<br>}<br>}<br>}  </p>\n<p>&#x2F;&#x2F; 坐标类<br>function Position(x, y) {<br>this.x &#x3D; x;<br>this.y &#x3D; y;<br>}  </p>\n<p>&#x2F;&#x2F;————————————————————————–&#x2F;&#x2F;<br>&#x2F;&#x2F; 内联调试器类<br>&#x2F;&#x2F;————————————————————————–&#x2F;&#x2F;<br>function InlineDebugger() {<br>var bpList &#x3D; new Array();<br>var id_eval;  </p>\n<p>&#x2F;&#x2F; 设置断点<br>var bp &#x3D; function(funcName) {<br>&#x2F;&#x2F; 检查eval是否被hook<br>if ((new String(eval)).indexOf(“[native code]“) &lt; 0) {<br>return “error: eval function was hooked by other codes in the front.\\n”;<br>}  </p>\n<p>&#x2F;&#x2F; 保存未被hooked的eval<br>id_eval &#x3D; eval;  </p>\n<p>var re &#x3D; &#x2F;^[a-zA-Z0-9_\\.]+$&#x2F;i;<br>if (! re.test(funcName)) {<br>return “error: bad argument of command bp \\“” + funcName + “\\“.\\n”;<br>}  </p>\n<p>try {<br>id_eval(“if (typeof(“ + funcName + “) &#x3D;&#x3D; \\“object\\“ || typeof(“ + funcName + “) &#x3D;&#x3D; \\“function\\“) {var obj &#x3D; “ + funcName + “;}”);<br>} catch (e) {<br>return “error: “ + e + “, invalid function name \\“” + funcName + “\\“.\\n”;<br>}  </p>\n<p>if (obj &#x3D;&#x3D; undefined) {<br>return “error: the argument of command bp \\“” + funcName + “\\“ is not a function object.\\n”;<br>}  </p>\n<p>if ((new String(obj)).indexOf(“function”) &lt; 0) {<br>return “error: the argument of command bp \\“” + funcName + “\\“ is a property, a function is required.\\n”;<br>}  </p>\n<p>if (bpList.search(funcName) &gt;&#x3D; 0) {<br>return “error: there is a breakpoint on function \\“” + funcName + “\\“\\n”;<br>}  </p>\n<p>try {<br>var sc &#x3D; “window.” + funcName.replace(&#x2F;\\.&#x2F;g, “_“) + “_bak &#x3D; “ + funcName + “;\\n” +<br>funcName + “ &#x3D; “ +<br>“function() {\\n” +<br>“ var args &#x3D; \\“\\“;\\n” +<br>“ for (var i &#x3D; 0; i &lt; arguments.length; i ++) {\\n” +<br>“ args +&#x3D; arguments[i] + (i &#x3D;&#x3D; (arguments.length - 1) ? \\“\\“ : \\“,\\“);\\n” +<br>“ }\\n” +<br>“ if (confirm(\\“function \\\\\\“” + funcName + “\\\\\\“ was called, execute it?\\\\n\\\\narguments:\\\\n\\“ + args + \\“\\\\n\\\\ncaller:\\\\n\\“ + “ + funcName + “.caller)) {\\n” +<br>“ id_eval(\\“” + funcName.replace(&#x2F;\\.&#x2F;g, “_“) + “_bak(\\\\\\“\\“ + jsEncode(args) + \\“\\\\\\“)\\“);\\n” +<br>“ }\\n” +<br>“};” +<br>“\\n”;<br>id_eval(sc);<br>bpList.push(funcName);<br>return “* breakpoint on function \\“” + funcName + “\\“ added successfully.\\n”;<br>} catch (e) {<br>return “unkown error: “ + e + “.\\n”;<br>}<br>}  </p>\n<p>&#x2F;&#x2F; 枚举所有的断点<br>var bl &#x3D; function() {<br>if (bpList.length &#x3D;&#x3D; 0) {<br>return “* no breakpoint.\\n”;<br>}  </p>\n<p>var bps &#x3D; “* “ + bpList.length + “ breakpoints: \\n”;  </p>\n<p>for (var i &#x3D; 0; i &lt; bpList.length; i ++) {<br>bps +&#x3D; i + “ - “ + bpList[i] + “\\n”;<br>}  </p>\n<p>return bps;<br>}  </p>\n<p>&#x2F;&#x2F; 清除某个断点<br>var bc &#x3D; function(n) {<br>try {<br>n &#x3D; parseInt(n);<br>} catch (e) {<br>return “error: bc command requires a numeric argument.\\n”;<br>}  </p>\n<p>if (bpList.length &#x3D;&#x3D; 0) {<br>return “error: no breakpoint.\\n”;<br>}  </p>\n<p>var funcName &#x3D; bpList.remove(n);  </p>\n<p>try {<br>eval(funcName + “ &#x3D; window.” + funcName.replace(&#x2F;\\.&#x2F;g, “_“) + “_bak;”);<br>return “* breakpoint on function \\“” + funcName + “\\“ deleted successfully.\\n”;<br>} catch (e) {<br>return “error: “ + e + “.\\n”;<br>}<br>}  </p>\n<p>&#x2F;&#x2F; 帮助<br>var help &#x3D; function() {<br>var s &#x3D; “debug commands:\\n\\n” +<br>“bp <function name> - set a breakpoint on a function, e.g. \\“bp window.alert\\“.\\n” +<br>“bl - list all breakpoints.\\n” +<br>“bc <breakpoint number> - remove a breakpoint by specified number, e.g. \\“bc 0\\“.\\n” +<br>“help - help information.\\n”<br>“\\n”;<br>return s;<br>}  </p>\n<p>&#x2F;&#x2F; 处理命令<br>this.exeCmd &#x3D; function(cmd) {<br>cmd &#x3D; cmd.trim();<br>var cmdParts &#x3D; cmd.split(&#x2F;\\s+&#x2F;g);<br>var cmdName;<br>var cmdArg;  </p>\n<p>if (cmdParts.length &#x3D;&#x3D; 1) {<br>cmdName &#x3D; cmd;<br>} else {<br>cmdName &#x3D; cmdParts[0];<br>cmdArg &#x3D; cmdParts[1];<br>}  </p>\n<p>switch (cmdName) {<br>case “bp”:<br>if (cmdArg &#x3D;&#x3D; undefined) {<br>return “error: bp command requires an argument.\\n”;<br>} else {<br>return bp(cmdArg);<br>}<br>break;  </p>\n<p>case “bl”:<br>return bl();<br>break;  </p>\n<p>case “bc”:<br>if (cmdArg &#x3D;&#x3D; undefined) {<br>return “error: bc command requires an argument \\“number of breakpoint\\“.\\n”;<br>} else {<br>return bc(cmdArg);<br>}<br>break;  </p>\n<p>case “help”:<br>return help();<br>break;  </p>\n<p>default: return “error: command \\“” + cmdName + “\\“ not found, you can get information by \\“help\\“ command.\\n”;<br>break;<br>}<br>}<br>}  </p>\n<p>&#x2F;&#x2F;—————————————————————————–&#x2F;&#x2F;<br>&#x2F;&#x2F; 主过程<br>&#x2F;&#x2F;—————————————————————————–&#x2F;&#x2F;<br>&#x2F;*try {<br>debugger;<br>} catch (e) {}*&#x2F;<br>var id &#x3D; new InlineDebugger();<br>var console &#x3D; new Console(document.body, function(s, printProc){printProc(id.exeCmd(s));});</p>\n","more":"<p>一篇非常好的javascript Function应用文章。 原文地址： <a href=\"http://www.xfocus.net/articles/200712/963.html\">http://www.xfocus.net/articles/200712/963.html</a> ———————————————————————————————– 一、概述 javascri…</p>\n<!-- more -->\n<p>一篇非常好的javascript Function应用文章。<br>原文地址： <a href=\"http://www.xfocus.net/articles/200712/963.html\">http://www.xfocus.net/articles/200712/963.html</a>  </p>\n<p>-———————————————————————————————-  </p>\n<p><strong>一、概述</strong>  </p>\n<p>javascript函数劫持，也就是老外提到的javascript hijacking技术。最早还是和剑心同学讨论问题时偶然看到的一段代码，大概这样写的：<br>window.alert &#x3D; function(s) {};<br>觉得这种用法很巧妙新颖，和API Hook异曲同工，索性称之为javascript function hook，也就是函数劫持。通过替换js函数的实现来达到劫持这个函数调用的目的，一个完整的hook alert函数例子如下：  </p>\n<!--1.htm-->  \n<script type=\"text/javascript\">  \n<!--  \nvar \\_alert = alert;  \nwindow.alert = function(s) {  \nif (confirm(\"是否要弹框框，内容是\\\\\"\" + s + \"\\\\\"？\")) {  \n\\_alert(s);  \n}  \n}  \n//-->  \n</script>  \n<html>  \n<body>  \n<input type=\"button\" onclick=\"javascript: alert(Hello World!)\" value=\"test\" />  \n</body>  \n</html>  \n\n  \n  \n<p>搞过API Hook的同学们看到这个代码一定会心的一笑，先保存原函数实现，然后替换为我们自己的函数实现，添加我们自己的处理逻辑后最终再调用原来的函数实现，这样这个alert函数就被我们劫持了。原理非常简单，下面举些典型的应用来看看我们能利用它来做些什么。  </p>\n<p><strong>二、应用举例</strong>  </p>\n<p>1. 实现一个简易的javascript debugger，这里说是debugger比较标题党，其实只是有点类似于debugger的功能，主要利用js函数劫持来实现函数的break point，来看看个简单的例子：  </p>\n<script type=\"text/javascript\">  \n<!--  \nvar \\_eval = eval;  \neval = function(s) {  \nif (confirm(\"eval被调用\\\\n\\\\n调用函数\\\\n\" + eval.caller + \"\\\\n\\\\n调用参数\\\\n\" + s)) {  \n\\_eval(s);  \n}  \n}  \n//-->  \n</script>  \n<html>  \n<head>  \n</head>  \n<body>  \n<script type=\"text/javascript\">  \n<!--  \nfunction test() {  \nvar a = \"alert(1)\";  \neval(a);  \n}  \n  \n<p>function t() {<br>test();<br>}  </p>\n<p>t();<br>&#x2F;&#x2F;–&gt;<br></script>  </p>\n</body>  \n</html>  \n\n  \n  \n<p>通过js函数劫持中断函数执行，并显示参数和函数调用者代码，来看一个完整例子的效果：  </p>\n<p>&gt;help<br>debug commands:  </p>\n<p>bp <function name> - set a breakpoint on a function, e.g. “bp window.alert”.<br>bl - list all breakpoints.<br>bc <breakpoint number> - remove a breakpoint by specified number, e.g. “bc 0”.<br>help - help information.  </p>\n<p>&gt;bp window.alert<br>* breakpoint on function “window.alert” added successfully.  </p>\n<p>&gt;bl<br>* 1 breakpoints:<br>0 - window.alert  </p>\n<p>&gt;bc 0<br>* breakpoint on function “window.alert” deleted successfully.  </p>\n<p>这里演示设置断点，察看断点和删除断点，完整代码在本文附录[1]给出。  </p>\n<p>2. 设置陷阱实时捕捉跨站测试者，搞跨站的人总习惯用alert来确认是否存在跨站，如果你要监控是否有人在测试你的网站xss的话，可以在你要监控的页面里hook alert函数，记录alert调用情况：  </p>\n<script type=\"text/javascript\">  \n<!--  \nfunction log(s) {  \nvar img = new Image();  \nimg.style.width = img.style.height = 0;  \nimg.src = \"[http://yousite.com/log.php?caller=\"](http://yousite.com/log.php?caller=\") + encodeURIComponent(s);  \n}  \n  \nvar \\_alert = alert;  \nwindow.alert = function(s) {  \nlog(alert.caller);  \n\\_alert(s);  \n}  \n//-->  \n</script>  \n\n<p>当然，你这个函数要加到页面的最开始，而且还要比较隐蔽一些，赫赫，你甚至可以使alert不弹框或者弹个警告框，让测试者抓狂一把。  </p>\n<p>3. 实现DOM XSS自动化扫描，目前一般的XSS自动化扫描的方法是从http返回结果中搜索特征来确定是否存在漏洞，但是这种方法不适用于扫描DOM XSS，因为DOM XSS是由客户端脚本造成的，比如前段时间剑心发现的google的跨站(见附录[2])原理如下：  </p>\n<p>document.write(document.location.hash);  </p>\n<p>这样的跨站无法反映在http response里，所以传统扫描方法没法扫描出来。但是如果你从上个例子里受到启发的话，一定会想到设置陷阱的办法，DOM XSS最终导致alert被执行，所以我们hook alert函数设置陷阱，如果XSS成功则会去调用alert函数，触发我们的陷阱记录结果，这样就可以实现DOM XSS的自动化扫描，陷阱代码类似于上面。  </p>\n<p>4. 灵活的使用js劫持辅助你的页面代码分析工作，比如分析网页木马时，经常会有通过eval或者document.write来进行加密的情况，于是我们编写段hook eval和document.write的小工具，辅助解密：  </p>\n<script type=\"text/javascript\">  \n<!--  \nvar \\_eval = eval;  \neval = window.execScript = window.document.write = window.document.writeln = function(s) {  \ndocument.getElementById(\"output\").value = s;  \n}  \n//-->  \n</script>  \n<html>  \n<body>  \ninput:  \n<!--<textarea id=\"input\" cols=\"80\" rows=\"10\"></textarea>-->  \n<input type=\"button\" onclick=\"javascript: \\_eval(document.getElementById(input).value);\" value=\"decode\" />  \n<br />  \noutput:  \n<!--<textarea id=\"output\" cols=\"80\" rows=\"10\"></textarea>-->  \n</body>  \n</html>  \n\n  \n  \n<p>在input框里输入加密的代码：  </p>\n<p>eval(unescape(“%61%6C%65%72%74%28%31%29%3B”));  </p>\n<p>在output框里输出解码后的代码：  </p>\n<p>alert(1);  </p>\n<p>当然你还能想到更多的灵活应用：）  </p>\n<p><strong>三、反劫持</strong>  </p>\n<p>谈到劫持也就必然要谈谈反劫持的话题，假设你要写一个健壮的xss playload，就需要考虑反劫持，有两个问题要解决：  </p>\n<p>如何判断是否被劫持了？<br>如果发现被劫持了，如何反劫持？  </p>\n<p>1. 判断某个函数是否被劫持，这个好办，写个小程序对比一下一个函数被hook前后，有什么差别：  </p>\n<!--<textarea id=\"tb1\" cols=\"80\" rows=\"8\"></textarea>-->  \n<script type=\"text/javascript\">  \n<!--  \ndocument.getElementById(\"tb1\").value = eval + \"\\\\n\";  \nvar \\_eval = eval;  \neval = function(s) {  \nalert(s);  \n\\_eval(s);  \n}  \ndocument.getElementById(\"tb1\").value += eval;  \n//-->  \n</script>  \n\n<p>结果：  </p>\n<p>function eval() {<br>[native code]<br>}  </p>\n<p>function(s) {<br>alert(s);<br>_eval(s);<br>}  </p>\n<p>我们发现那些内置函数是[native code]，而自定义的则是具体的函数定义，用这个特征就可以简单的检测函数是否被劫持：  </p>\n<p>function checkHook(proc) {<br>if (proc.toString().indexOf(“[native code]“) &gt; 0) {<br>return false;<br>} else {<br>return true;<br>}<br>}  </p>\n<p>2. 如何反劫持，第一个想法就是恢复被劫持的函数，如果劫持的人把原函数保存在某个变量里那还好办，直接调用原函数就可以了，但是劫持者自己也没保存副本怎么办，只能自己创建个新的环境，然后用新环境里的干净的函数来恢复我们这里被hook了的，怎么创建新环境？整个新的iframe好了，里面就是个全新的环境。ok，动手吧：  </p>\n<p>function unHook(proc) {<br>var f &#x3D; document.createElement(“iframe”);<br>f.style.border &#x3D; “0”;<br>f.style.width &#x3D; “0”;<br>f.style.height &#x3D; “0”;<br>document.body.appendChild(f);  </p>\n<p>var d &#x3D; f.contentWindow.document;<br>d.write(“&lt;script type&#x3D;\\“text&#x2F;javascript\\“&gt;window.parent.escape &#x3D; escape;&lt;\\&#x2F;script&gt;”);<br>d.close();<br>}  </p>\n<p>综合1、2节，整个测试代码如下：  </p>\n<!--antihook.htm-->  \n<script type=\"text/javascript\">  \n<!--  \nescape = function(s) {  \nreturn s;  \n}  \n//-->  \n</script>  \n<html>  \n<body>  \n<input type=\"button\" onclick=\"javascript: test();\" value=\"test\" />  \n<script type=\"text/javascript\">  \n<!--  \nfunction test() {  \nalert(escape(\"s y\"));  \n  \n<p>if (checkHook(escape)) {<br>unHook(escape);<br>}  </p>\n<p>alert(escape(“s y”));<br>}  </p>\n<p>function checkHook(proc) {<br>if (proc.toString().indexOf(“[native code]“) &gt; 0) {<br>return false;<br>} else {<br>return true;<br>}<br>}  </p>\n<p>function unHook(proc) {<br>var f &#x3D; document.createElement(“iframe”);<br>f.style.border &#x3D; “0”;<br>f.style.width &#x3D; “0”;<br>f.style.height &#x3D; “0”;<br>document.body.appendChild(f);  </p>\n<p>var d &#x3D; f.contentWindow.document;<br>d.write(“&lt;script type&#x3D;\\“text&#x2F;javascript\\“&gt;window.parent.escape &#x3D; escape;&lt;\\&#x2F;script&gt;”);<br>d.close();<br>}<br>&#x2F;&#x2F;–&gt;<br></script>  </p>\n</body>  \n</html>  \n\n  \n  \n<p>3. 不是上面两个问题都解决了么，为什么要有第3节？因为那不是个最好的解决办法，既然我们可以创建全新的iframe，何不把代码直接放到全新iframe 里执行呢，这样做的话绿色环保，既不用考虑当前context里的hook问题，也不用改动当前context，不会影响本身的程序执行。给出两个比较通用点的函数：  </p>\n<p>function createIframe(w) {<br>var d &#x3D; w.document;<br>var newIframe &#x3D; d.createElement(“iframe”);<br>newIframe.style.width &#x3D; 0;<br>newIframe.style.height &#x3D; 0;<br>d.body.appendChild(newIframe);<br>newIframe.contentWindow.document.write(“<html><body></body></html>“);<br>return newIframe;<br>}  </p>\n<p>function injectScriptIntoIframe(f, proc) {<br>var d &#x3D; f.contentWindow.document;<br>var s &#x3D; “<script>\\n(\" + proc.toString() + \")();\\n</script>“;<br>d.write(s);<br>}  </p>\n<p>把你的payload封装进一个函数，然后调用这两个方法来在iframe里执行：  </p>\n<p>function payload() {<br>&#x2F;&#x2F; your code goes here<br>}  </p>\n<p>var f &#x3D; createIframe(top);<br>injectScriptIntoIframe(f, payload);  </p>\n<p><strong>四、最后</strong>  </p>\n<p>由于国内很少有见文章提及这个东西，所以才草成这篇，希望能够抛砖引玉。由于本人水平有限，难免有错误或者疏漏之处请谅解，没有说清楚的地方，欢迎和我交流。  </p>\n<p>还有就是一些不得不感谢的人，感谢剑心一直以来毫无保留的交流，感谢黑锅多次鼓励我把自己的心得体会写成文字，感谢幻影所有的朋友们、B.C.T的朋友们以及群里那帮经常一起扯淡的朋友们。  </p>\n<p>广告一下，没法幻影blog的朋友，可以添加hosts来突破：<br>72.14.219.190 pstgroup.blogspot.com  </p>\n<p><strong>五、附录</strong>  </p>\n<p>[1] 简易的javascript inline debugger代码  </p>\n<!--test.htm-->  \n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"[http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"><p>](<a href=\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd%22%3E\">http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;</a>)  </p>\n<html xmlns=\"[http://www.w3.org/1999/xhtml\">](http://www.w3.org/1999/xhtml\">)  \n<head><title>Javascript Inline Debugger</title></head>  \n<body>  \n<script language=\"javascript\" type=\"text/javascript\" src=\"js\\_inline\\_debugger.js\"></script>  \n<input type=\"button\" value=\"hahaha\" onclick=\"javascript: alert(this.value);\" style=\"margin-left: 300px;\" />  \n</body>  \n</html>  \n  \n  \n<p>&#x2F;*<br>FileName: js_inline_debugger.js<br>Author: luoluo<br>Contact: luoluonet_at_yahoo.cn<br>Date: 2007-6-27<br>Version: 0.1<br>Usage:<br><!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"[http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">](<a href=\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd%22%3E\">http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;</a>)  </p>\n<html xmlns=\"[http://www.w3.org/1999/xhtml\">](http://www.w3.org/1999/xhtml\">)  \n<head>  \n</head>  \n<body>  \n<script language=\"javascript\" type=\"text/javascript\" src=\"js\\_inline\\_debugger.js\"></script>  \n</body>  \n</html>  \nInstruction:  \nIt is a simple javascript inline debugger. You must add xhtml1-transitional dtd to your  \nhtml document if you wanna to use the script.  \n\\*/  \n  \n<p>&#x2F;&#x2F;————————————————————————–&#x2F;&#x2F;<br>&#x2F;&#x2F; 公用的函数<br>&#x2F;&#x2F;————————————————————————–&#x2F;&#x2F;<br>&#x2F;&#x2F; 判断是否是IE<br>function isIE() {<br>return document.all &amp;&amp; window.external;<br>}  </p>\n<p>&#x2F;&#x2F; 去除字符串两边的空格<br>String.prototype.trim &#x3D; function() {<br>var re &#x3D; &#x2F;(^\\s*)|(\\s*)$&#x2F;g;<br>return this.replace(re, “”);<br>}  </p>\n<p>&#x2F;&#x2F; 删除数组中某个元素<br>Array.prototype.remove &#x3D; function(i) {<br>var o &#x3D; this[i];<br>for (var j &#x3D; i; j &lt; this.length - 1; j ++) {<br>this[j] &#x3D; this[j + 1];<br>}<br>-- this.length;<br>return o;<br>}  </p>\n<p>&#x2F;&#x2F; 判断一个数组中是否存在相同的元素<br>Array.prototype.search &#x3D; function(o) {<br>for (var i &#x3D; 0; i &lt; this.length; i ++) {<br>if (this[i] &#x3D;&#x3D; o) {<br>return i;<br>}<br>}  </p>\n<p>return -1;<br>}  </p>\n<p>&#x2F;&#x2F; html编码<br>function htmlEncode(s) {<br>s &#x3D; s.replace(&#x2F;&amp;&#x2F;g, “&amp;”);<br>s &#x3D; s.replace(&#x2F;&lt;&#x2F;g, “&lt;”);<br>s &#x3D; s.replace(&#x2F;&gt;&#x2F;g, “&gt;”);<br>s &#x3D; s.replace(&#x2F;\\“&#x2F;g, “””);<br>s &#x3D; s.replace(&#x2F;\\&#x2F;g, “””);  </p>\n<p>return s;<br>}  </p>\n<p>&#x2F;&#x2F; js编码<br>function jsEncode(s) {<br>s &#x3D; s.replace(&#x2F;\\\\&#x2F;g, “\\\\\\\\“);<br>s &#x3D; s.replace(&#x2F;\\n&#x2F;g, “\\\\n”);<br>s &#x3D; s.replace(&#x2F;\\“&#x2F;g, “\\\\\\“”);<br>s &#x3D; s.replace(&#x2F;\\&#x2F;g, “\\\\\\“);<br>return s;<br>}  </p>\n<p>&#x2F;&#x2F;————————————————————–&#x2F;&#x2F;<br>&#x2F;&#x2F; 命令行窗口工具<br>&#x2F;&#x2F;————————————————————–&#x2F;&#x2F;<br>function Console(parentNode, processInputProc) {<br>&#x2F;&#x2F; 窗口<br>var panel &#x3D; document.createElement(“div”);<br>panel.style.width &#x3D; “250px”;<br>panel.style.height &#x3D; “250px”;<br>panel.style.borderColor &#x3D; “#666666”;<br>panel.style.borderWidth &#x3D; “1px”;<br>panel.style.backgroundColor &#x3D; “#ffffff”;<br>panel.style.borderStyle &#x3D; “solid”;<br>panel.style.position &#x3D; “absolute”;<br>panel.style.zIndex &#x3D; 100;<br>parentNode.appendChild(panel);  </p>\n<p>&#x2F;&#x2F; 标题栏<br>var title &#x3D; document.createElement(“div”);<br>title.style.width &#x3D; “250px”;<br>title.style.height &#x3D; “15px”;<br>title.style.backgroundColor &#x3D; “#dddddd”;<br>title.style.fontSize &#x3D; “12px”;<br>title.style.fontFamily &#x3D; “verdana,tahoma”;<br>panel.appendChild(title);  </p>\n<p>&#x2F;&#x2F; 标题栏拖动窗口功能<br>var isDragging &#x3D; false;<br>var startPos &#x3D; new Position(panel.offsetLeft, panel.offsetTop);<br>var startMousePos &#x3D; new Position(0, 0);  </p>\n<p>title.onmouseover &#x3D; function(evt) {<br>this.style.cursor &#x3D; “pointer”;<br>}  </p>\n<p>title.onmousedown &#x3D; function(evt) {<br>if (isDragging &#x3D;&#x3D; true) {<br>return;<br>}  </p>\n<p>var event &#x3D; evt || window.event;<br>startMousePos.x &#x3D; event.clientX;<br>startMousePos.y &#x3D; event.clientY;<br>isDragging &#x3D; true;<br>}  </p>\n<p>title.onmousemove &#x3D; function(evt) {<br>if (isDragging &#x3D;&#x3D; false) {<br>return;<br>}  </p>\n<p>activateWindow();<br>var event &#x3D; evt || window.event;<br>panel.style.left &#x3D; (event.clientX - startMousePos.x) + startPos.x + “px”;<br>panel.style.top &#x3D; (event.clientY - startMousePos.y) + startPos.y + “px”;<br>}  </p>\n<p>title.onmouseup &#x3D; function(evt) {<br>if (isDragging &#x3D;&#x3D; false) {<br>return;<br>}  </p>\n<p>var event &#x3D; evt || window.event;<br>startPos.x &#x3D; (event.clientX - startMousePos.x) + startPos.x;<br>panel.style.left &#x3D; startPos.x + “px”;<br>startPos.y &#x3D; (event.clientY - startMousePos.y) + startPos.y;<br>panel.style.top &#x3D; startPos.y + “px”;<br>isDragging &#x3D; false;<br>}  </p>\n<p>&#x2F;&#x2F; 关闭窗口功能<br>var closeButton &#x3D; document.createElement(“div”);<br>closeButton.style.width &#x3D; “13px”;<br>closeButton.style.height &#x3D; “13px”;<br>closeButton.style.backgroundColor &#x3D; “#ffffff”;<br>closeButton.style.styleFloat &#x3D; closeButton.style.cssFloat &#x3D; “left”;<br>closeButton.style.fontSize &#x3D; “12px”;<br>closeButton.style.borderWidth &#x3D; “1px”;<br>closeButton.style.borderColor &#x3D; “#999999”;<br>closeButton.style.borderStyle &#x3D; “solid”;<br>closeButton.style.paddingButton &#x3D; “2px”;<br>closeButton.innerHTML &#x3D; “&lt;div style&#x3D;\\“margin-top: -2px;margin-left: 3px;\\“&gt;x</div>“;<br>title.appendChild(closeButton);  </p>\n<p>var isVisible &#x3D; true;  </p>\n<p>&#x2F;&#x2F; 窗口关闭<br>closeButton.onclick &#x3D; function(evt) {<br>isVisible &#x3D; false;<br>panel.style.display &#x3D; “none”;<br>}  </p>\n<p>&#x2F;&#x2F; 标题栏文字<br>var titleLabel &#x3D; document.createElement(“div”);<br>titleLabel.style.height &#x3D; “14px”;<br>titleLabel.style.width &#x3D; “200px”;<br>titleLabel.style.fontSize &#x3D; “11px”;<br>titleLabel.style.color &#x3D; “#ffffff”;<br>titleLabel.style.styleFloat &#x3D; titleLabel.style.cssFloat &#x3D; “left”;<br>titleLabel.style.fontFamily &#x3D; “verdana,tahoma”;<br>titleLabel.innerHTML &#x3D; “Javascript Inline Debugger”;<br>&#x2F;&#x2F;titleLabel.style.marginTop &#x3D; isIE() ? -14 : “-14px”;<br>titleLabel.style.marginLeft &#x3D; isIE() ? 18 : “18px”;<br>title.appendChild(titleLabel);  </p>\n<p>&#x2F;&#x2F; 中间的显示部分<br>var showPanel &#x3D; document.createElement(“div”);<br>showPanel.style.width &#x3D; “250px”;<br>showPanel.style.height &#x3D; isIE() ? “221px” : “219px”;<br>showPanel.style.fontSize &#x3D; “11px”;<br>showPanel.style.padding &#x3D; “0”;<br>showPanel.style.margin &#x3D; “0”;<br>showPanel.style.overflow &#x3D; “auto”;<br>showPanel.style.marginTop &#x3D; isIE() ? -1 : “0”;<br>panel.appendChild(showPanel);  </p>\n<p>&#x2F;&#x2F; 命令输入框<br>var cmdArea &#x3D; document.createElement(“div”);<br>panel.appendChild(cmdArea);  </p>\n<p>var cmdTextbox &#x3D; document.createElement(“input”);<br>cmdTextbox.type &#x3D; “text”;<br>cmdTextbox.style.width &#x3D; “250px”;<br>cmdTextbox.style.height &#x3D; “12px”;<br>cmdTextbox.style.fontSize &#x3D; “12px”;<br>cmdTextbox.style.padding &#x3D; “0”;<br>cmdTextbox.style.margin &#x3D; “0”;<br>cmdTextbox.style.marginTop &#x3D; isIE() ? -2 : “0”;<br>cmdTextbox.style.borderWidth &#x3D; “0”;<br>cmdTextbox.style.borderTopWidth &#x3D; “1px”;<br>cmdTextbox.style.paddingTop &#x3D; “2px”;<br>cmdArea.appendChild(cmdTextbox);  </p>\n<p>&#x2F;&#x2F; 窗口激活或者不激活<br>var isActive &#x3D; false;  </p>\n<p>&#x2F;&#x2F; 激活窗口<br>var activateWindow &#x3D; function() {<br>if (! isVisible) {<br>return;<br>}  </p>\n<p>if (isActive) {<br>return;<br>}  </p>\n<p>cmdTextbox.focus();<br>title.style.backgroundColor &#x3D; “#015DF4”;<br>isActive &#x3D; true;<br>}  </p>\n<p>panel.onclick &#x3D; activateWindow;  </p>\n<p>&#x2F;&#x2F; 不激活窗口<br>var deactivateWindow &#x3D; function() {<br>if (! isVisible) {<br>return;<br>}  </p>\n<p>if (! isActive) {<br>return;<br>}  </p>\n<p>title.style.backgroundColor &#x3D; “#cccccc”;<br>isActive &#x3D; false;<br>}  </p>\n<p>cmdTextbox.onfocus &#x3D; activateWindow;<br>cmdTextbox.onblur &#x3D; deactivateWindow;  </p>\n<p>&#x2F;&#x2F; 输出函数<br>var dbgPrint &#x3D; function(s) {<br>showPanel.innerHTML +&#x3D; htmlEncode(s).replace(&#x2F;\\n|(\\r\\n)&#x2F;g, “<br />“);  </p>\n<p>if (parseInt(showPanel.scrollHeight) &gt; parseInt(showPanel.style.height)) {<br>showPanel.scrollTop +&#x3D; parseInt(showPanel.scrollHeight) - parseInt(showPanel.style.height);<br>}<br>}  </p>\n<p>&#x2F;&#x2F; 调用输入处理回调函数<br>cmdTextbox.onkeydown &#x3D; function(evt) {<br>var event &#x3D; evt || window.event;  </p>\n<p>if (event.keyCode &#x3D;&#x3D; 0x0d) {<br>processInputProc(this.value, dbgPrint);<br>this.value &#x3D; “”;<br>}<br>}<br>}  </p>\n<p>&#x2F;&#x2F; 坐标类<br>function Position(x, y) {<br>this.x &#x3D; x;<br>this.y &#x3D; y;<br>}  </p>\n<p>&#x2F;&#x2F;————————————————————————–&#x2F;&#x2F;<br>&#x2F;&#x2F; 内联调试器类<br>&#x2F;&#x2F;————————————————————————–&#x2F;&#x2F;<br>function InlineDebugger() {<br>var bpList &#x3D; new Array();<br>var id_eval;  </p>\n<p>&#x2F;&#x2F; 设置断点<br>var bp &#x3D; function(funcName) {<br>&#x2F;&#x2F; 检查eval是否被hook<br>if ((new String(eval)).indexOf(“[native code]“) &lt; 0) {<br>return “error: eval function was hooked by other codes in the front.\\n”;<br>}  </p>\n<p>&#x2F;&#x2F; 保存未被hooked的eval<br>id_eval &#x3D; eval;  </p>\n<p>var re &#x3D; &#x2F;^[a-zA-Z0-9_\\.]+$&#x2F;i;<br>if (! re.test(funcName)) {<br>return “error: bad argument of command bp \\“” + funcName + “\\“.\\n”;<br>}  </p>\n<p>try {<br>id_eval(“if (typeof(“ + funcName + “) &#x3D;&#x3D; \\“object\\“ || typeof(“ + funcName + “) &#x3D;&#x3D; \\“function\\“) {var obj &#x3D; “ + funcName + “;}”);<br>} catch (e) {<br>return “error: “ + e + “, invalid function name \\“” + funcName + “\\“.\\n”;<br>}  </p>\n<p>if (obj &#x3D;&#x3D; undefined) {<br>return “error: the argument of command bp \\“” + funcName + “\\“ is not a function object.\\n”;<br>}  </p>\n<p>if ((new String(obj)).indexOf(“function”) &lt; 0) {<br>return “error: the argument of command bp \\“” + funcName + “\\“ is a property, a function is required.\\n”;<br>}  </p>\n<p>if (bpList.search(funcName) &gt;&#x3D; 0) {<br>return “error: there is a breakpoint on function \\“” + funcName + “\\“\\n”;<br>}  </p>\n<p>try {<br>var sc &#x3D; “window.” + funcName.replace(&#x2F;\\.&#x2F;g, “_“) + “_bak &#x3D; “ + funcName + “;\\n” +<br>funcName + “ &#x3D; “ +<br>“function() {\\n” +<br>“ var args &#x3D; \\“\\“;\\n” +<br>“ for (var i &#x3D; 0; i &lt; arguments.length; i ++) {\\n” +<br>“ args +&#x3D; arguments[i] + (i &#x3D;&#x3D; (arguments.length - 1) ? \\“\\“ : \\“,\\“);\\n” +<br>“ }\\n” +<br>“ if (confirm(\\“function \\\\\\“” + funcName + “\\\\\\“ was called, execute it?\\\\n\\\\narguments:\\\\n\\“ + args + \\“\\\\n\\\\ncaller:\\\\n\\“ + “ + funcName + “.caller)) {\\n” +<br>“ id_eval(\\“” + funcName.replace(&#x2F;\\.&#x2F;g, “_“) + “_bak(\\\\\\“\\“ + jsEncode(args) + \\“\\\\\\“)\\“);\\n” +<br>“ }\\n” +<br>“};” +<br>“\\n”;<br>id_eval(sc);<br>bpList.push(funcName);<br>return “* breakpoint on function \\“” + funcName + “\\“ added successfully.\\n”;<br>} catch (e) {<br>return “unkown error: “ + e + “.\\n”;<br>}<br>}  </p>\n<p>&#x2F;&#x2F; 枚举所有的断点<br>var bl &#x3D; function() {<br>if (bpList.length &#x3D;&#x3D; 0) {<br>return “* no breakpoint.\\n”;<br>}  </p>\n<p>var bps &#x3D; “* “ + bpList.length + “ breakpoints: \\n”;  </p>\n<p>for (var i &#x3D; 0; i &lt; bpList.length; i ++) {<br>bps +&#x3D; i + “ - “ + bpList[i] + “\\n”;<br>}  </p>\n<p>return bps;<br>}  </p>\n<p>&#x2F;&#x2F; 清除某个断点<br>var bc &#x3D; function(n) {<br>try {<br>n &#x3D; parseInt(n);<br>} catch (e) {<br>return “error: bc command requires a numeric argument.\\n”;<br>}  </p>\n<p>if (bpList.length &#x3D;&#x3D; 0) {<br>return “error: no breakpoint.\\n”;<br>}  </p>\n<p>var funcName &#x3D; bpList.remove(n);  </p>\n<p>try {<br>eval(funcName + “ &#x3D; window.” + funcName.replace(&#x2F;\\.&#x2F;g, “_“) + “_bak;”);<br>return “* breakpoint on function \\“” + funcName + “\\“ deleted successfully.\\n”;<br>} catch (e) {<br>return “error: “ + e + “.\\n”;<br>}<br>}  </p>\n<p>&#x2F;&#x2F; 帮助<br>var help &#x3D; function() {<br>var s &#x3D; “debug commands:\\n\\n” +<br>“bp <function name> - set a breakpoint on a function, e.g. \\“bp window.alert\\“.\\n” +<br>“bl - list all breakpoints.\\n” +<br>“bc <breakpoint number> - remove a breakpoint by specified number, e.g. \\“bc 0\\“.\\n” +<br>“help - help information.\\n”<br>“\\n”;<br>return s;<br>}  </p>\n<p>&#x2F;&#x2F; 处理命令<br>this.exeCmd &#x3D; function(cmd) {<br>cmd &#x3D; cmd.trim();<br>var cmdParts &#x3D; cmd.split(&#x2F;\\s+&#x2F;g);<br>var cmdName;<br>var cmdArg;  </p>\n<p>if (cmdParts.length &#x3D;&#x3D; 1) {<br>cmdName &#x3D; cmd;<br>} else {<br>cmdName &#x3D; cmdParts[0];<br>cmdArg &#x3D; cmdParts[1];<br>}  </p>\n<p>switch (cmdName) {<br>case “bp”:<br>if (cmdArg &#x3D;&#x3D; undefined) {<br>return “error: bp command requires an argument.\\n”;<br>} else {<br>return bp(cmdArg);<br>}<br>break;  </p>\n<p>case “bl”:<br>return bl();<br>break;  </p>\n<p>case “bc”:<br>if (cmdArg &#x3D;&#x3D; undefined) {<br>return “error: bc command requires an argument \\“number of breakpoint\\“.\\n”;<br>} else {<br>return bc(cmdArg);<br>}<br>break;  </p>\n<p>case “help”:<br>return help();<br>break;  </p>\n<p>default: return “error: command \\“” + cmdName + “\\“ not found, you can get information by \\“help\\“ command.\\n”;<br>break;<br>}<br>}<br>}  </p>\n<p>&#x2F;&#x2F;—————————————————————————–&#x2F;&#x2F;<br>&#x2F;&#x2F; 主过程<br>&#x2F;&#x2F;—————————————————————————–&#x2F;&#x2F;<br>&#x2F;*try {<br>debugger;<br>} catch (e) {}*&#x2F;<br>var id &#x3D; new InlineDebugger();<br>var console &#x3D; new Console(document.body, function(s, printProc){printProc(id.exeCmd(s));});</p>\n","categories":[],"tags":[]}
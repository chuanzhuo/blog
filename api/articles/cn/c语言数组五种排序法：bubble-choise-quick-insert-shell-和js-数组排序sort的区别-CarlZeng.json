{"title":"c语言数组五种排序法：bubble,choise,quick,insert,shell 和js 数组排序sort的区别-CarlZeng","slug":"cn/c语言数组五种排序法：bubble-choise-quick-insert-shell-和js-数组排序sort的区别-CarlZeng","date":"2009-01-05T07:43:00.000Z","updated":"2023-10-08T14:21:10.120Z","comments":true,"path":"api/articles/cn/c语言数组五种排序法：bubble-choise-quick-insert-shell-和js-数组排序sort的区别-CarlZeng.json","excerpt":"（1）\"冒泡法\" 冒泡法大家都较熟悉。其原理为从a[0]开始，依次将其和后面的元素比较,若a[0]>a[i]，则交换它们，一直比较到a[n]。同理对a[1],a[2],...a[n-1]处理，即完成排序。下面列出其代码：void bubble(int *a,int n) /*定义两个参数：数组首地址与数组大小*/{int i,j,temp;for(i=0;ia[j]) {temp=a[i];a[i...","covers":["http://www.blogjava.net/Images/OutliningIndicators/None.gif"],"content":"<p>（1）”冒泡法” 冒泡法大家都较熟悉。其原理为从a[0]开始，依次将其和后面的元素比较,若a[0]&gt;a[i]，则交换它们，一直比较到a[n]。同理对a[1],a[2],…a[n-1]处理，即完成排序。下面列出其代码：void bubble(int *a,int n) &#x2F;*定义两个参数：数组首地址与数组大小*&#x2F;{int i,j,temp;for(i&#x3D;0;ia[j]) {temp&#x3D;a[i];a[i…</p>\n<!-- more -->\n<p>**（1）”冒泡法”<br>**冒泡法大家都较熟悉。其原理为从a[0]开始，依次将其和后面的元素比较,若a[0]&gt;a[i]，则交换它们，一直比较到a[n]。同理对a[1],a[2],…a[n-1]处理，即完成排序。下面列出其代码：  </p>\n<p>void bubble(int *a,int n) &#x2F;*定义两个参数：数组首地址与数组大小*&#x2F;<br>{<br>int i,j,temp;<br>for(i&#x3D;0;i&lt;n-1;i++)<br>for(j&#x3D;i+1;j&lt;n;j++) &#x2F;*注意循环的上下限*&#x2F;<br>if(a[i]&gt;a[j]) {<br>temp&#x3D;a[i];<br>a[i]&#x3D;a[j];<br>a[j]&#x3D;temp;<br>}<br>}  </p>\n<p>冒泡法原理简单，但其缺点是交换次数多，效率低。<br>下面介绍一种源自冒泡法但更有效率的方法”选择法”。</p>\n<p><strong>（2）”选择法”</strong><br>选择法循环过程与冒泡法一致，它还定义了记号k&#x3D;i,然后依次把a[k]同后面元素比较，若a[k]&gt;a[j],则使k&#x3D;j.最后看看k&#x3D;i是否还成立，不成立则交换a[k],a[i],这样就比冒泡法省下许多无用的交换，提高了效率。  </p>\n<p>void choise(int *a,int n)<br>{<br>int i,j,k,temp;<br>for(i&#x3D;0;i&lt;n-1;i++) {<br>k&#x3D;i; &#x2F;*给记号赋值*&#x2F;<br>for(j&#x3D;i+1;j&lt;n;j++)<br>if(a[k]&gt;a[j]) k&#x3D;j; &#x2F;*是k总是指向最小元素*&#x2F;<br>if(i!&#x3D;k) { &#x2F;*当k!&#x3D;i是才交换，否则a[i]即为最小*&#x2F;<br>temp&#x3D;a[i];<br>a[i]&#x3D;a[k];<br>a[k]&#x3D;temp;<br>}<br>}<br>}  </p>\n<p>选择法比冒泡法效率更高，但说到高效率，非”快速法”莫属，现在就让我们来了解它。</p>\n<p><strong>（3）”快速法”</strong><br>快速法定义了三个参数，（数组首地址*a,要排序数组起始元素下标i,要排序数组结束元素下标j). 它首先选一个数组元素（一般为a[(i+j)&#x2F;2],即中间元素）作为参照，把比它小的元素放到它的左边，比它大的放在右边。然后运用递归，在将它左，右两个子数组排序，最后完成整个数组的排序。下面分析其代码：  </p>\n<p>void quick(int *a,int i,int j)<br>{<br>int m,n,temp;<br>int k;<br>m&#x3D;i;<br>n&#x3D;j;<br>k&#x3D;a[(i+j)&#x2F;2]; &#x2F;*选取的参照*&#x2F;<br>do {<br>while(a[m]&lt;k&amp;&amp;m&lt;j) m++; &#x2F;* 从左到右找比k大的元素*&#x2F;<br>while(a[n]&gt;k&amp;&amp;n&gt;i) n–; &#x2F;* 从右到左找比k小的元素*&#x2F;<br>if(m&lt;&#x3D;n) { &#x2F;*若找到且满足条件，则交换*&#x2F;<br>temp&#x3D;a[m];<br>a[m]&#x3D;a[n];<br>a[n]&#x3D;temp;<br>m++;<br>n–;<br>}<br>}while(m&lt;&#x3D;n);<br>if(m&lt;j) quick(a,m,j); &#x2F;*运用递归*&#x2F;<br>if(n&gt;i) quick(a,i,n);<br>}</p>\n<p><strong>（4）”插入法”</strong><br>插入法是一种比较直观的排序方法。它首先把数组头两个元素排好序，再依次把后面的元素插入适当的位置。把数组元素插完也就完成了排序。  </p>\n<p>void insert(int *a,int n)<br>{<br>int i,j,temp;<br>for(i&#x3D;1;i&lt;n;i++) {<br>temp&#x3D;a[i]; &#x2F;*temp为要插入的元素*&#x2F;<br>j&#x3D;i-1;<br>while(j&gt;&#x3D;0&amp;&amp;temp&lt;a[j]) { &#x2F;*从a[i-1]开始找比a[i]小的数，同时把数组元素向后移*&#x2F;<br>a[j+1]&#x3D;a[j];<br>j–;<br>}<br>a[j+1]&#x3D;temp; &#x2F;*插入*&#x2F;<br>}<br>}</p>\n<p><strong>（5）”shell法”</strong><br>shell法是一个叫 shell 的美国人与1969年发明的。它首先把相距k(k&gt;&#x3D;1)的那几个元素排好序，再缩小k值（一般取其一半），再排序，直到k&#x3D;1时完成排序。下面让我们来分析其代码：  </p>\n<p>void shell(int *a,int n)<br>{<br>int i,j,k,x;<br>k&#x3D;n&#x2F;2; &#x2F;*间距值*&#x2F;<br>while(k&gt;&#x3D;1) {<br>for(i&#x3D;k;i&lt;n;i++) {<br>x&#x3D;a[i];<br>j&#x3D;i-k;<br>while(j&gt;&#x3D;0&amp;&amp;x&lt;a[j]) {<br>a[j+k]&#x3D;a[j];<br>j-&#x3D;k;<br>}<br>a[j+k]&#x3D;x;<br>}<br>k&#x2F;&#x3D;2; &#x2F;*缩小间距值*&#x2F;<br>}<br>}</p>\n<p>=&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p>\n<p>下面讲js的数组排序sort方法：</p>\n<p>sort的概念：</p>\n<p><img data-src=\"http://www.blogjava.net/Images/OutliningIndicators/None.gif\">返回一个元素已经进行了排序的 Array 对象。<br><img data-src=\"http://www.blogjava.net/Images/OutliningIndicators/None.gif\">arrayobj.sort(sortfunction)<br><img data-src=\"http://www.blogjava.net/Images/OutliningIndicators/None.gif\">参数<br><img data-src=\"http://www.blogjava.net/Images/OutliningIndicators/None.gif\">arrayObj<br><img data-src=\"http://www.blogjava.net/Images/OutliningIndicators/None.gif\">必选项。任意 Array 对象。<br>参数：sortFunction</p>\n<p>　　可选项。是用来确定元素顺序的函数的名称。如果这个参数被省略，那么元素将按照 ASCII 字符顺序进行升序排列。</p>\n<p>　　sort 方法将 Array 对象进行适当的排序；在执行过程中并不会创建新的 Array 对象。</p>\n<p>　　如果为 sortfunction 参数提供了一个函数，那么该函数必须返回下列值之一：</p>\n<p>　　负值，如果所传递的第一个参数比第二个参数小。</p>\n<p>　　零，如果两个参数相等。</p>\n<p>　　正值，如果第一个参数比第二个参数大。</p>\n<p>　　<strong>以上的方法在一维的排序还是很方便的，但像SQL语句中的ORDER BY 一样的，因此arrayObject.sort( sortFunction )的排序功能还是很强大的，终于能够实现了SQL语句中的ORDER BY 一样的功能。</strong></p>\n<p>sort的的应用：</p>\n<p>sort();</p>\n<p>sort(function(a,b){ return a-b; });</p>\n<p>sort(function(a,b){ return a.localeCompare(b) });</p>\n<p>sort(function(){ return Math.random()&gt;0.5?-1:1; });</p>\n<p>sort(function(a,b){ return a.indexOf(str)&#x3D;&#x3D;-1?1:-1; });</p>\n<p>测试数据：</p>\n<p>var y&#x3D;new Array( 36000 , 500 , 10100 );<br>y.sort(function(a,b){ return a-b; });<br>alert(y);</p>\n","more":"<p>（1）”冒泡法” 冒泡法大家都较熟悉。其原理为从a[0]开始，依次将其和后面的元素比较,若a[0]&gt;a[i]，则交换它们，一直比较到a[n]。同理对a[1],a[2],…a[n-1]处理，即完成排序。下面列出其代码：void bubble(int *a,int n) &#x2F;*定义两个参数：数组首地址与数组大小*&#x2F;{int i,j,temp;for(i&#x3D;0;ia[j]) {temp&#x3D;a[i];a[i…</p>\n<!-- more -->\n<p>**（1）”冒泡法”<br>**冒泡法大家都较熟悉。其原理为从a[0]开始，依次将其和后面的元素比较,若a[0]&gt;a[i]，则交换它们，一直比较到a[n]。同理对a[1],a[2],…a[n-1]处理，即完成排序。下面列出其代码：  </p>\n<p>void bubble(int *a,int n) &#x2F;*定义两个参数：数组首地址与数组大小*&#x2F;<br>{<br>int i,j,temp;<br>for(i&#x3D;0;i&lt;n-1;i++)<br>for(j&#x3D;i+1;j&lt;n;j++) &#x2F;*注意循环的上下限*&#x2F;<br>if(a[i]&gt;a[j]) {<br>temp&#x3D;a[i];<br>a[i]&#x3D;a[j];<br>a[j]&#x3D;temp;<br>}<br>}  </p>\n<p>冒泡法原理简单，但其缺点是交换次数多，效率低。<br>下面介绍一种源自冒泡法但更有效率的方法”选择法”。</p>\n<p><strong>（2）”选择法”</strong><br>选择法循环过程与冒泡法一致，它还定义了记号k&#x3D;i,然后依次把a[k]同后面元素比较，若a[k]&gt;a[j],则使k&#x3D;j.最后看看k&#x3D;i是否还成立，不成立则交换a[k],a[i],这样就比冒泡法省下许多无用的交换，提高了效率。  </p>\n<p>void choise(int *a,int n)<br>{<br>int i,j,k,temp;<br>for(i&#x3D;0;i&lt;n-1;i++) {<br>k&#x3D;i; &#x2F;*给记号赋值*&#x2F;<br>for(j&#x3D;i+1;j&lt;n;j++)<br>if(a[k]&gt;a[j]) k&#x3D;j; &#x2F;*是k总是指向最小元素*&#x2F;<br>if(i!&#x3D;k) { &#x2F;*当k!&#x3D;i是才交换，否则a[i]即为最小*&#x2F;<br>temp&#x3D;a[i];<br>a[i]&#x3D;a[k];<br>a[k]&#x3D;temp;<br>}<br>}<br>}  </p>\n<p>选择法比冒泡法效率更高，但说到高效率，非”快速法”莫属，现在就让我们来了解它。</p>\n<p><strong>（3）”快速法”</strong><br>快速法定义了三个参数，（数组首地址*a,要排序数组起始元素下标i,要排序数组结束元素下标j). 它首先选一个数组元素（一般为a[(i+j)&#x2F;2],即中间元素）作为参照，把比它小的元素放到它的左边，比它大的放在右边。然后运用递归，在将它左，右两个子数组排序，最后完成整个数组的排序。下面分析其代码：  </p>\n<p>void quick(int *a,int i,int j)<br>{<br>int m,n,temp;<br>int k;<br>m&#x3D;i;<br>n&#x3D;j;<br>k&#x3D;a[(i+j)&#x2F;2]; &#x2F;*选取的参照*&#x2F;<br>do {<br>while(a[m]&lt;k&amp;&amp;m&lt;j) m++; &#x2F;* 从左到右找比k大的元素*&#x2F;<br>while(a[n]&gt;k&amp;&amp;n&gt;i) n–; &#x2F;* 从右到左找比k小的元素*&#x2F;<br>if(m&lt;&#x3D;n) { &#x2F;*若找到且满足条件，则交换*&#x2F;<br>temp&#x3D;a[m];<br>a[m]&#x3D;a[n];<br>a[n]&#x3D;temp;<br>m++;<br>n–;<br>}<br>}while(m&lt;&#x3D;n);<br>if(m&lt;j) quick(a,m,j); &#x2F;*运用递归*&#x2F;<br>if(n&gt;i) quick(a,i,n);<br>}</p>\n<p><strong>（4）”插入法”</strong><br>插入法是一种比较直观的排序方法。它首先把数组头两个元素排好序，再依次把后面的元素插入适当的位置。把数组元素插完也就完成了排序。  </p>\n<p>void insert(int *a,int n)<br>{<br>int i,j,temp;<br>for(i&#x3D;1;i&lt;n;i++) {<br>temp&#x3D;a[i]; &#x2F;*temp为要插入的元素*&#x2F;<br>j&#x3D;i-1;<br>while(j&gt;&#x3D;0&amp;&amp;temp&lt;a[j]) { &#x2F;*从a[i-1]开始找比a[i]小的数，同时把数组元素向后移*&#x2F;<br>a[j+1]&#x3D;a[j];<br>j–;<br>}<br>a[j+1]&#x3D;temp; &#x2F;*插入*&#x2F;<br>}<br>}</p>\n<p><strong>（5）”shell法”</strong><br>shell法是一个叫 shell 的美国人与1969年发明的。它首先把相距k(k&gt;&#x3D;1)的那几个元素排好序，再缩小k值（一般取其一半），再排序，直到k&#x3D;1时完成排序。下面让我们来分析其代码：  </p>\n<p>void shell(int *a,int n)<br>{<br>int i,j,k,x;<br>k&#x3D;n&#x2F;2; &#x2F;*间距值*&#x2F;<br>while(k&gt;&#x3D;1) {<br>for(i&#x3D;k;i&lt;n;i++) {<br>x&#x3D;a[i];<br>j&#x3D;i-k;<br>while(j&gt;&#x3D;0&amp;&amp;x&lt;a[j]) {<br>a[j+k]&#x3D;a[j];<br>j-&#x3D;k;<br>}<br>a[j+k]&#x3D;x;<br>}<br>k&#x2F;&#x3D;2; &#x2F;*缩小间距值*&#x2F;<br>}<br>}</p>\n<p>=&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p>\n<p>下面讲js的数组排序sort方法：</p>\n<p>sort的概念：</p>\n<p><img data-src=\"http://www.blogjava.net/Images/OutliningIndicators/None.gif\">返回一个元素已经进行了排序的 Array 对象。<br><img data-src=\"http://www.blogjava.net/Images/OutliningIndicators/None.gif\">arrayobj.sort(sortfunction)<br><img data-src=\"http://www.blogjava.net/Images/OutliningIndicators/None.gif\">参数<br><img data-src=\"http://www.blogjava.net/Images/OutliningIndicators/None.gif\">arrayObj<br><img data-src=\"http://www.blogjava.net/Images/OutliningIndicators/None.gif\">必选项。任意 Array 对象。<br>参数：sortFunction</p>\n<p>　　可选项。是用来确定元素顺序的函数的名称。如果这个参数被省略，那么元素将按照 ASCII 字符顺序进行升序排列。</p>\n<p>　　sort 方法将 Array 对象进行适当的排序；在执行过程中并不会创建新的 Array 对象。</p>\n<p>　　如果为 sortfunction 参数提供了一个函数，那么该函数必须返回下列值之一：</p>\n<p>　　负值，如果所传递的第一个参数比第二个参数小。</p>\n<p>　　零，如果两个参数相等。</p>\n<p>　　正值，如果第一个参数比第二个参数大。</p>\n<p>　　<strong>以上的方法在一维的排序还是很方便的，但像SQL语句中的ORDER BY 一样的，因此arrayObject.sort( sortFunction )的排序功能还是很强大的，终于能够实现了SQL语句中的ORDER BY 一样的功能。</strong></p>\n<p>sort的的应用：</p>\n<p>sort();</p>\n<p>sort(function(a,b){ return a-b; });</p>\n<p>sort(function(a,b){ return a.localeCompare(b) });</p>\n<p>sort(function(){ return Math.random()&gt;0.5?-1:1; });</p>\n<p>sort(function(a,b){ return a.indexOf(str)&#x3D;&#x3D;-1?1:-1; });</p>\n<p>测试数据：</p>\n<p>var y&#x3D;new Array( 36000 , 500 , 10100 );<br>y.sort(function(a,b){ return a-b; });<br>alert(y);</p>\n","categories":[{"name":"Javascript","path":"api/categories/Javascript.json"}],"tags":[{"name":"Javascript","path":"api/tags/Javascript.json"},{"name":"JS","path":"api/tags/JS.json"}]}
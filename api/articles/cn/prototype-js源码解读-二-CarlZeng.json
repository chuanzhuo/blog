{"title":"prototype.js源码解读(二)-CarlZeng","slug":"cn/prototype-js源码解读-二-CarlZeng","date":"2010-02-25T08:27:00.000Z","updated":"2023-10-02T02:27:29.017Z","comments":true,"path":"api/articles/cn/prototype-js源码解读-二-CarlZeng.json","excerpt":"/*** 使表单的第一个非 hidden 类型而且处于可用状态的元素获得焦点*/focusFirstElement: function(form) {form = $(form);var elements = Form.getElements(form);for (var i = 0; i < elements.length; i++) {var element ...","covers":null,"content":"<p>&#x2F;** * 使表单的第一个非 hidden 类型而且处于可用状态的元素获得焦点 *&#x2F; focusFirstElement: function(form) { form &#x3D; $(form); var elements &#x3D; Form.getElements(form); for (var i &#x3D; 0; i &lt; elements.length; i++) { var element …</p>\n<!-- more -->\n<hr>\n<p>&#x2F;**<br>* 使表单的第一个非 hidden 类型而且处于可用状态的元素获得焦点<br>*&#x2F;<br>focusFirstElement: function(form) {<br>form &#x3D; $(form);<br>var elements &#x3D; Form.getElements(form);<br>for (var i &#x3D; 0; i &lt; elements.length; i++) {<br>var element &#x3D; elements[i];<br>if (element.type !&#x3D; ‘hidden’ &amp;&amp; !element.disabled) {<br>Field.activate(element);<br>break;<br>}<br>}<br>},  </p>\n<p>&#x2F;*<br>* 重置表单<br>*&#x2F;<br>reset: function(form) {<br>$(form).reset();<br>}<br>}  </p>\n<p>&#x2F;**<br>* 表单元素工具类<br>*&#x2F;<br>Form.Element &#x3D; {<br>&#x2F;**<br>* 返回表单元素的值先序列化再进行 URL 编码后的值<br>*&#x2F;<br>serialize: function(element) {<br>element &#x3D; $(element);<br>var method &#x3D; element.tagName.toLowerCase();<br>var parameter &#x3D; Form.Element.Serializers[method](element);  </p>\n<p>if (parameter)<br>return encodeURIComponent(parameter[0]) + ‘&#x3D;’ +<br>encodeURIComponent(parameter[1]);<br>},  </p>\n<p>&#x2F;**<br>* 返回表单元素序列化后的值<br>*&#x2F;<br>getValue: function(element) {<br>element &#x3D; $(element);<br>var method &#x3D; element.tagName.toLowerCase();<br>var parameter &#x3D; Form.Element.Serializers[method](element);  </p>\n<p>if (parameter)<br>return parameter[1];<br>}<br>}  </p>\n<p>&#x2F;**<br>* prototype 的所谓序列化其实就是将表单的名字和值组合成一个数组<br>*&#x2F;<br>Form.Element.Serializers &#x3D; {<br>input: function(element) {<br>switch (element.type.toLowerCase()) {<br>case ‘hidden’:<br>case ‘password’:<br>case ‘text’:<br>return Form.Element.Serializers.textarea(element);<br>case ‘checkbox’:<br>case ‘radio’:<br>return Form.Element.Serializers.inputSelector(element);<br>}<br>return false;<br>},  </p>\n<p>inputSelector: function(element) {<br>if (element.checked)<br>return [element.name, element.value];<br>},  </p>\n<p>textarea: function(element) {<br>return [element.name, element.value];<br>},  </p>\n<p>&#x2F;**<br>* 看样子，也不支持多选框(select-multiple)<br>*&#x2F;<br>select: function(element) {<br>var index &#x3D; element.selectedIndex;<br>var value &#x3D; element.options[index].value || element.options[index].text;<br>return [element.name, (index &gt;&#x3D; 0) ? value : ‘’];<br>}<br>}  </p>\n<p>&#x2F;*————————————————————————–*&#x2F;  </p>\n<p>&#x2F;**<br>* Form.Element.getValue 也许会经常用到，所以做了一个快捷引用<br>*&#x2F;<br>var $F &#x3D; Form.Element.getValue;  </p>\n<p>&#x2F;*————————————————————————–*&#x2F;  </p>\n<p>&#x2F;**<br>* Abstract.TimedObserver 也没有用 Class.create() 来创建，和Ajax.Base 意图应该一样<br>* Abstract.TimedObserver 顾名思义，是套用Observer设计模式来跟踪指定表单元素，<br>* 当表单元素的值发生变化的时候，就执行回调函数<br>*<br>* 我想　Observer 与注册onchange事件相似，不同点在于 onchange 事件是在元素失去焦点的时候才激发。<br>* 同样的与 onpropertychange 事件也相似，不过它只关注表单元素的值的变化，而且提供timeout的控制。<br>*<br>* 除此之外，Observer 的好处大概就在与更面向对象，另外可以动态的更换回调函数，这就比注册事件要灵活一些。<br>* Observer 应该可以胜任动态数据校验，或者多个关联下拉选项列表的连动等等<br>*<br>*&#x2F;<br>Abstract.TimedObserver &#x3D; function() {}  </p>\n<p>&#x2F;**<br>* 这个设计和 PeriodicalExecuter 一样，bind 方法是实现的核心<br>*&#x2F;<br>Abstract.TimedObserver.prototype &#x3D; {<br>initialize: function(element, frequency, callback) {<br>this.frequency &#x3D; frequency;<br>this.element &#x3D; $(element);<br>this.callback &#x3D; callback;  </p>\n<p>this.lastValue &#x3D; this.getValue();<br>this.registerCallback();<br>},  </p>\n<p>registerCallback: function() {<br>setTimeout(this.onTimerEvent.bind(this), this.frequency * 1000);<br>},  </p>\n<p>onTimerEvent: function() {<br>var value &#x3D; this.getValue();<br>if (this.lastValue !&#x3D; value) {<br>this.callback(this.element, value);<br>this.lastValue &#x3D; value;<br>}  </p>\n<p>this.registerCallback();<br>}<br>}  </p>\n<p>&#x2F;**<br>* Form.Element.Observer 和 Form.Observer 其实是一样的<br>* 注意 Form.Observer 并不是用来跟踪整个表单的，我想大概只是为了减少书写(这是Ruby的一个设计原则)<br>*&#x2F;<br>Form.Element.Observer &#x3D; Class.create();<br>Form.Element.Observer.prototype &#x3D; (new Abstract.TimedObserver()).extend({<br>getValue: function() {<br>return Form.Element.getValue(this.element);<br>}<br>});  </p>\n<p>Form.Observer &#x3D; Class.create();<br>Form.Observer.prototype &#x3D; (new Abstract.TimedObserver()).extend({<br>getValue: function() {<br>return Form.serialize(this.element);<br>}<br>});<br>&#x2F;**<br>* 根据 class attribute 的名字得到对象数组，支持 multiple class<br>*<br>*&#x2F;<br>document.getElementsByClassName &#x3D; function(className) {<br>var children &#x3D; document.getElementsByTagName(‘*‘) || document.all;<br>var elements &#x3D; new Array();  </p>\n<p>for (var i &#x3D; 0; i &lt; children.length; i++) {<br>var child &#x3D; children[i];<br>var classNames &#x3D; child.className.split(‘ ‘);<br>for (var j &#x3D; 0; j &lt; classNames.length; j++) {<br>if (classNames[j] &#x3D;&#x3D; className) {<br>elements.push(child);<br>break;<br>}<br>}<br>}  </p>\n<p>return elements;<br>}  </p>\n<p>&#x2F;*————————————————————————–*&#x2F;  </p>\n<p>&#x2F;**<br>* Element 就象一个 java 的工具类，主要用来 隐藏&#x2F;显示&#x2F;销除 对象，以及获取对象的简单属性。<br>*<br>*&#x2F;<br>var Element &#x3D; {<br>toggle: function() {<br>for (var i &#x3D; 0; i &lt; arguments.length; i++) {<br>var element &#x3D; $(arguments[i]);<br>element.style.display &#x3D;<br>(element.style.display &#x3D;&#x3D; ‘none’ ? ‘’ : ‘none’);<br>}<br>},  </p>\n<p>hide: function() {<br>for (var i &#x3D; 0; i &lt; arguments.length; i++) {<br>var element &#x3D; $(arguments[i]);<br>element.style.display &#x3D; ‘none’;<br>}<br>},  </p>\n<p>show: function() {<br>for (var i &#x3D; 0; i &lt; arguments.length; i++) {<br>var element &#x3D; $(arguments[i]);<br>element.style.display &#x3D; ‘’;<br>}<br>},  </p>\n<p>remove: function(element) {<br>element &#x3D; $(element);<br>element.parentNode.removeChild(element);<br>},  </p>\n<p>getHeight: function(element) {<br>element &#x3D; $(element);<br>return element.offsetHeight;<br>}<br>}  </p>\n<p>&#x2F;**<br>* 为 Element.toggle 做了一个符号连接，大概是兼容性的考虑<br>*&#x2F;<br>var Toggle &#x3D; new Object();<br>Toggle.display &#x3D; Element.toggle;  </p>\n<p>&#x2F;*————————————————————————–*&#x2F;  </p>\n<p>&#x2F;**<br>* 动态插入内容的实现，MS的Jscript实现中对象有一个 insertAdjacentHTML 方法(http: &#x2F;&#x2F;msdn.microsoft.com&#x2F;workshop&#x2F;author&#x2F;dhtml&#x2F;reference&#x2F;methods&#x2F;insertadjacenthtml.asp)<br>* 这里算是一个对象形式的封装。<br>*&#x2F;<br>Abstract.Insertion &#x3D; function(adjacency) {<br>this.adjacency &#x3D; adjacency;<br>}  </p>\n<p>Abstract.Insertion.prototype &#x3D; {<br>initialize: function(element, content) {<br>this.element &#x3D; $(element);<br>this.content &#x3D; content;  </p>\n<p>if (this.adjacency &amp;&amp; this.element.insertAdjacentHTML) {<br>this.element.insertAdjacentHTML(this.adjacency, this.content);<br>} else {<br>&#x2F;**<br>* gecko 不支持 insertAdjacentHTML 方法，但可以用如下代码代替<br>*&#x2F;<br>this.range &#x3D; this.element.ownerDocument.createRange();<br>&#x2F;**<br>* 如果定义了 initializeRange 方法，则实行，这里相当与定义了一个抽象的 initializeRange 方法<br>*&#x2F;<br>if (this.initializeRange) this.initializeRange();<br>this.fragment &#x3D; this.range.createContextualFragment(this.content);  </p>\n<p>&#x2F;**<br>* insertContent 也是一个抽象方法，子类必须实现<br>*&#x2F;<br>this.insertContent();<br>}<br>}<br>}  </p>\n<p>&#x2F;**<br>* prototype 加深了我的体会，就是写js 如何去遵循　Don’t Repeat Yourself (DRY) 原则<br>* 上文中 Abstract.Insertion 算是一个抽象类，定义了名为　initializeRange 的一个抽象方法<br>* var Insertion &#x3D; new Object()　建立一个命名空间<br>* Insertion.Before|Top|Bottom|After 就象是四个java中的四个静态内部类，而它们分别继承于Abstract.Insertion，并实现了initializeRange方法。<br>*&#x2F;<br>var Insertion &#x3D; new Object();  </p>\n<p>Insertion.Before &#x3D; Class.create();<br>Insertion.Before.prototype &#x3D; (new Abstract.Insertion(‘beforeBegin’)).extend({<br>initializeRange: function() {<br>this.range.setStartBefore(this.element);<br>},  </p>\n<p>&#x2F;**<br>* 将内容插入到指定节点的前面, 与指定节点同级<br>*&#x2F;<br>insertContent: function() {<br>this.element.parentNode.insertBefore(this.fragment, this.element);<br>}<br>});  </p>\n<p>Insertion.Top &#x3D; Class.create();<br>Insertion.Top.prototype &#x3D; (new Abstract.Insertion(‘afterBegin’)).extend({<br>initializeRange: function() {<br>this.range.selectNodeContents(this.element);<br>this.range.collapse(true);<br>},  </p>\n<p>&#x2F;**<br>* 将内容插入到指定节点的第一个子节点前，于是内容变为该节点的第一个子节点<br>*&#x2F;<br>insertContent: function() {<br>this.element.insertBefore(this.fragment, this.element.firstChild);<br>}<br>});  </p>\n<p>Insertion.Bottom &#x3D; Class.create();<br>Insertion.Bottom.prototype &#x3D; (new Abstract.Insertion(‘beforeEnd’)).extend({<br>initializeRange: function() {<br>this.range.selectNodeContents(this.element);<br>this.range.collapse(this.element);<br>},  </p>\n<p>&#x2F;**<br>* 将内容插入到指定节点的最后，于是内容变为该节点的最后一个子节点<br>*&#x2F;<br>insertContent: function() {<br>this.element.appendChild(this.fragment);<br>}<br>});  </p>\n<p>Insertion.After &#x3D; Class.create();<br>Insertion.After.prototype &#x3D; (new Abstract.Insertion(‘afterEnd’)).extend({<br>initializeRange: function() {<br>this.range.setStartAfter(this.element);<br>},  </p>\n<p>&#x2F;**<br>* 将内容插入到指定节点的后面, 与指定节点同级<br>*&#x2F;<br>insertContent: function() {<br>this.element.parentNode.insertBefore(this.fragment,<br>this.element.nextSibling);<br>}<br>});</p>\n<p>from: <a href=\"http://forum.j2eemx.com/ajax-ajax-discussions/1026-prototype-javascript.html\">http://forum.j2eemx.com/ajax-ajax-discussions/1026-prototype-javascript.html</a></p>\n","more":"<p>&#x2F;** * 使表单的第一个非 hidden 类型而且处于可用状态的元素获得焦点 *&#x2F; focusFirstElement: function(form) { form &#x3D; $(form); var elements &#x3D; Form.getElements(form); for (var i &#x3D; 0; i &lt; elements.length; i++) { var element …</p>\n<!-- more -->\n<hr>\n<p>&#x2F;**<br>* 使表单的第一个非 hidden 类型而且处于可用状态的元素获得焦点<br>*&#x2F;<br>focusFirstElement: function(form) {<br>form &#x3D; $(form);<br>var elements &#x3D; Form.getElements(form);<br>for (var i &#x3D; 0; i &lt; elements.length; i++) {<br>var element &#x3D; elements[i];<br>if (element.type !&#x3D; ‘hidden’ &amp;&amp; !element.disabled) {<br>Field.activate(element);<br>break;<br>}<br>}<br>},  </p>\n<p>&#x2F;*<br>* 重置表单<br>*&#x2F;<br>reset: function(form) {<br>$(form).reset();<br>}<br>}  </p>\n<p>&#x2F;**<br>* 表单元素工具类<br>*&#x2F;<br>Form.Element &#x3D; {<br>&#x2F;**<br>* 返回表单元素的值先序列化再进行 URL 编码后的值<br>*&#x2F;<br>serialize: function(element) {<br>element &#x3D; $(element);<br>var method &#x3D; element.tagName.toLowerCase();<br>var parameter &#x3D; Form.Element.Serializers[method](element);  </p>\n<p>if (parameter)<br>return encodeURIComponent(parameter[0]) + ‘&#x3D;’ +<br>encodeURIComponent(parameter[1]);<br>},  </p>\n<p>&#x2F;**<br>* 返回表单元素序列化后的值<br>*&#x2F;<br>getValue: function(element) {<br>element &#x3D; $(element);<br>var method &#x3D; element.tagName.toLowerCase();<br>var parameter &#x3D; Form.Element.Serializers[method](element);  </p>\n<p>if (parameter)<br>return parameter[1];<br>}<br>}  </p>\n<p>&#x2F;**<br>* prototype 的所谓序列化其实就是将表单的名字和值组合成一个数组<br>*&#x2F;<br>Form.Element.Serializers &#x3D; {<br>input: function(element) {<br>switch (element.type.toLowerCase()) {<br>case ‘hidden’:<br>case ‘password’:<br>case ‘text’:<br>return Form.Element.Serializers.textarea(element);<br>case ‘checkbox’:<br>case ‘radio’:<br>return Form.Element.Serializers.inputSelector(element);<br>}<br>return false;<br>},  </p>\n<p>inputSelector: function(element) {<br>if (element.checked)<br>return [element.name, element.value];<br>},  </p>\n<p>textarea: function(element) {<br>return [element.name, element.value];<br>},  </p>\n<p>&#x2F;**<br>* 看样子，也不支持多选框(select-multiple)<br>*&#x2F;<br>select: function(element) {<br>var index &#x3D; element.selectedIndex;<br>var value &#x3D; element.options[index].value || element.options[index].text;<br>return [element.name, (index &gt;&#x3D; 0) ? value : ‘’];<br>}<br>}  </p>\n<p>&#x2F;*————————————————————————–*&#x2F;  </p>\n<p>&#x2F;**<br>* Form.Element.getValue 也许会经常用到，所以做了一个快捷引用<br>*&#x2F;<br>var $F &#x3D; Form.Element.getValue;  </p>\n<p>&#x2F;*————————————————————————–*&#x2F;  </p>\n<p>&#x2F;**<br>* Abstract.TimedObserver 也没有用 Class.create() 来创建，和Ajax.Base 意图应该一样<br>* Abstract.TimedObserver 顾名思义，是套用Observer设计模式来跟踪指定表单元素，<br>* 当表单元素的值发生变化的时候，就执行回调函数<br>*<br>* 我想　Observer 与注册onchange事件相似，不同点在于 onchange 事件是在元素失去焦点的时候才激发。<br>* 同样的与 onpropertychange 事件也相似，不过它只关注表单元素的值的变化，而且提供timeout的控制。<br>*<br>* 除此之外，Observer 的好处大概就在与更面向对象，另外可以动态的更换回调函数，这就比注册事件要灵活一些。<br>* Observer 应该可以胜任动态数据校验，或者多个关联下拉选项列表的连动等等<br>*<br>*&#x2F;<br>Abstract.TimedObserver &#x3D; function() {}  </p>\n<p>&#x2F;**<br>* 这个设计和 PeriodicalExecuter 一样，bind 方法是实现的核心<br>*&#x2F;<br>Abstract.TimedObserver.prototype &#x3D; {<br>initialize: function(element, frequency, callback) {<br>this.frequency &#x3D; frequency;<br>this.element &#x3D; $(element);<br>this.callback &#x3D; callback;  </p>\n<p>this.lastValue &#x3D; this.getValue();<br>this.registerCallback();<br>},  </p>\n<p>registerCallback: function() {<br>setTimeout(this.onTimerEvent.bind(this), this.frequency * 1000);<br>},  </p>\n<p>onTimerEvent: function() {<br>var value &#x3D; this.getValue();<br>if (this.lastValue !&#x3D; value) {<br>this.callback(this.element, value);<br>this.lastValue &#x3D; value;<br>}  </p>\n<p>this.registerCallback();<br>}<br>}  </p>\n<p>&#x2F;**<br>* Form.Element.Observer 和 Form.Observer 其实是一样的<br>* 注意 Form.Observer 并不是用来跟踪整个表单的，我想大概只是为了减少书写(这是Ruby的一个设计原则)<br>*&#x2F;<br>Form.Element.Observer &#x3D; Class.create();<br>Form.Element.Observer.prototype &#x3D; (new Abstract.TimedObserver()).extend({<br>getValue: function() {<br>return Form.Element.getValue(this.element);<br>}<br>});  </p>\n<p>Form.Observer &#x3D; Class.create();<br>Form.Observer.prototype &#x3D; (new Abstract.TimedObserver()).extend({<br>getValue: function() {<br>return Form.serialize(this.element);<br>}<br>});<br>&#x2F;**<br>* 根据 class attribute 的名字得到对象数组，支持 multiple class<br>*<br>*&#x2F;<br>document.getElementsByClassName &#x3D; function(className) {<br>var children &#x3D; document.getElementsByTagName(‘*‘) || document.all;<br>var elements &#x3D; new Array();  </p>\n<p>for (var i &#x3D; 0; i &lt; children.length; i++) {<br>var child &#x3D; children[i];<br>var classNames &#x3D; child.className.split(‘ ‘);<br>for (var j &#x3D; 0; j &lt; classNames.length; j++) {<br>if (classNames[j] &#x3D;&#x3D; className) {<br>elements.push(child);<br>break;<br>}<br>}<br>}  </p>\n<p>return elements;<br>}  </p>\n<p>&#x2F;*————————————————————————–*&#x2F;  </p>\n<p>&#x2F;**<br>* Element 就象一个 java 的工具类，主要用来 隐藏&#x2F;显示&#x2F;销除 对象，以及获取对象的简单属性。<br>*<br>*&#x2F;<br>var Element &#x3D; {<br>toggle: function() {<br>for (var i &#x3D; 0; i &lt; arguments.length; i++) {<br>var element &#x3D; $(arguments[i]);<br>element.style.display &#x3D;<br>(element.style.display &#x3D;&#x3D; ‘none’ ? ‘’ : ‘none’);<br>}<br>},  </p>\n<p>hide: function() {<br>for (var i &#x3D; 0; i &lt; arguments.length; i++) {<br>var element &#x3D; $(arguments[i]);<br>element.style.display &#x3D; ‘none’;<br>}<br>},  </p>\n<p>show: function() {<br>for (var i &#x3D; 0; i &lt; arguments.length; i++) {<br>var element &#x3D; $(arguments[i]);<br>element.style.display &#x3D; ‘’;<br>}<br>},  </p>\n<p>remove: function(element) {<br>element &#x3D; $(element);<br>element.parentNode.removeChild(element);<br>},  </p>\n<p>getHeight: function(element) {<br>element &#x3D; $(element);<br>return element.offsetHeight;<br>}<br>}  </p>\n<p>&#x2F;**<br>* 为 Element.toggle 做了一个符号连接，大概是兼容性的考虑<br>*&#x2F;<br>var Toggle &#x3D; new Object();<br>Toggle.display &#x3D; Element.toggle;  </p>\n<p>&#x2F;*————————————————————————–*&#x2F;  </p>\n<p>&#x2F;**<br>* 动态插入内容的实现，MS的Jscript实现中对象有一个 insertAdjacentHTML 方法(http: &#x2F;&#x2F;msdn.microsoft.com&#x2F;workshop&#x2F;author&#x2F;dhtml&#x2F;reference&#x2F;methods&#x2F;insertadjacenthtml.asp)<br>* 这里算是一个对象形式的封装。<br>*&#x2F;<br>Abstract.Insertion &#x3D; function(adjacency) {<br>this.adjacency &#x3D; adjacency;<br>}  </p>\n<p>Abstract.Insertion.prototype &#x3D; {<br>initialize: function(element, content) {<br>this.element &#x3D; $(element);<br>this.content &#x3D; content;  </p>\n<p>if (this.adjacency &amp;&amp; this.element.insertAdjacentHTML) {<br>this.element.insertAdjacentHTML(this.adjacency, this.content);<br>} else {<br>&#x2F;**<br>* gecko 不支持 insertAdjacentHTML 方法，但可以用如下代码代替<br>*&#x2F;<br>this.range &#x3D; this.element.ownerDocument.createRange();<br>&#x2F;**<br>* 如果定义了 initializeRange 方法，则实行，这里相当与定义了一个抽象的 initializeRange 方法<br>*&#x2F;<br>if (this.initializeRange) this.initializeRange();<br>this.fragment &#x3D; this.range.createContextualFragment(this.content);  </p>\n<p>&#x2F;**<br>* insertContent 也是一个抽象方法，子类必须实现<br>*&#x2F;<br>this.insertContent();<br>}<br>}<br>}  </p>\n<p>&#x2F;**<br>* prototype 加深了我的体会，就是写js 如何去遵循　Don’t Repeat Yourself (DRY) 原则<br>* 上文中 Abstract.Insertion 算是一个抽象类，定义了名为　initializeRange 的一个抽象方法<br>* var Insertion &#x3D; new Object()　建立一个命名空间<br>* Insertion.Before|Top|Bottom|After 就象是四个java中的四个静态内部类，而它们分别继承于Abstract.Insertion，并实现了initializeRange方法。<br>*&#x2F;<br>var Insertion &#x3D; new Object();  </p>\n<p>Insertion.Before &#x3D; Class.create();<br>Insertion.Before.prototype &#x3D; (new Abstract.Insertion(‘beforeBegin’)).extend({<br>initializeRange: function() {<br>this.range.setStartBefore(this.element);<br>},  </p>\n<p>&#x2F;**<br>* 将内容插入到指定节点的前面, 与指定节点同级<br>*&#x2F;<br>insertContent: function() {<br>this.element.parentNode.insertBefore(this.fragment, this.element);<br>}<br>});  </p>\n<p>Insertion.Top &#x3D; Class.create();<br>Insertion.Top.prototype &#x3D; (new Abstract.Insertion(‘afterBegin’)).extend({<br>initializeRange: function() {<br>this.range.selectNodeContents(this.element);<br>this.range.collapse(true);<br>},  </p>\n<p>&#x2F;**<br>* 将内容插入到指定节点的第一个子节点前，于是内容变为该节点的第一个子节点<br>*&#x2F;<br>insertContent: function() {<br>this.element.insertBefore(this.fragment, this.element.firstChild);<br>}<br>});  </p>\n<p>Insertion.Bottom &#x3D; Class.create();<br>Insertion.Bottom.prototype &#x3D; (new Abstract.Insertion(‘beforeEnd’)).extend({<br>initializeRange: function() {<br>this.range.selectNodeContents(this.element);<br>this.range.collapse(this.element);<br>},  </p>\n<p>&#x2F;**<br>* 将内容插入到指定节点的最后，于是内容变为该节点的最后一个子节点<br>*&#x2F;<br>insertContent: function() {<br>this.element.appendChild(this.fragment);<br>}<br>});  </p>\n<p>Insertion.After &#x3D; Class.create();<br>Insertion.After.prototype &#x3D; (new Abstract.Insertion(‘afterEnd’)).extend({<br>initializeRange: function() {<br>this.range.setStartAfter(this.element);<br>},  </p>\n<p>&#x2F;**<br>* 将内容插入到指定节点的后面, 与指定节点同级<br>*&#x2F;<br>insertContent: function() {<br>this.element.parentNode.insertBefore(this.fragment,<br>this.element.nextSibling);<br>}<br>});</p>\n<p>from: <a href=\"http://forum.j2eemx.com/ajax-ajax-discussions/1026-prototype-javascript.html\">http://forum.j2eemx.com/ajax-ajax-discussions/1026-prototype-javascript.html</a></p>\n","categories":[],"tags":[]}
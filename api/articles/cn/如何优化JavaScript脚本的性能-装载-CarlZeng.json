{"title":"如何优化JavaScript脚本的性能[装载]-CarlZeng","slug":"cn/如何优化JavaScript脚本的性能-装载-CarlZeng","date":"2009-07-14T07:06:00.000Z","updated":"2023-10-02T02:27:28.999Z","comments":true,"path":"api/articles/cn/如何优化JavaScript脚本的性能-装载-CarlZeng.json","excerpt":"如何优化JavaScript脚本的性能作者：ShiningRay @ Nirvana Studio随着网络的发展，网速和机器速度的提高，越来越多的网站用到了丰富客户端技术。而现在Ajax则是最为流行的一种方式。JavaScript是一种解释型语言，所以能无法达到和C/Java之类的水平，限制了它能在客户端所做的事情，为了能改进他的性能，我想基于我以前给JavaScript做过的很多测试来谈谈...","covers":null,"content":"<p>如何优化JavaScript脚本的性能 作者：ShiningRay @ Nirvana Studio 随着网络的发展，网速和机器速度的提高，越来越多的网站用到了丰富客户端技术。而现在Ajax则是最为流行的一种方式。JavaScript是一种解释型语言，所以能无法达到和C&#x2F;Java之类的水平，限制了它能在客户端所做的事情，为了能改进他的性能，我想基于我以前给JavaScript做过的很多测试来谈谈…</p>\n<!-- more -->\n<h2 id=\"如何优化JavaScript脚本的性能\"><a href=\"#如何优化JavaScript脚本的性能\" class=\"headerlink\" title=\"如何优化JavaScript脚本的性能\"></a>如何优化JavaScript脚本的性能</h2><p>作者：ShiningRay @ <a href=\"http://www.nirvanastudio.org/\">Nirvana Studio</a></p>\n<p>随着网络的发展，网速和机器速度的提高，越来越多的网站用到了丰富客户端技术。而现在Ajax则是最为流行的一种方式。JavaScript是一种解释型语言，所以能无法达到和C&#x2F;Java之类的水平，限制了它能在客户端所做的事情，为了能改进他的性能，我想基于我以前给JavaScript做过的很多测试来谈谈自己的经验，希望能帮助大家改进自己的JavaScript脚本性能。</p>\n<h1 id=\"语言层次方面\"><a href=\"#语言层次方面\" class=\"headerlink\" title=\"语言层次方面\"></a>语言层次方面</h1><h2 id=\"循环\"><a href=\"#循环\" class=\"headerlink\" title=\"循环\"></a>循环</h2><p>循环是很常用的一个控制结构，大部分东西要依靠它来完成，在JavaScript中，我们可以使用<code>for(;;),while(),for(in)</code>三种循环，事实上，这三种循环中<code>for(in)</code>的效率极差，因为他需要查询散列键，只要可以就应该尽量少用。<code>for(;;)</code>和<code>while</code>循环的性能应该说基本（平时使用时）等价。</p>\n<p>而事实上，如何使用这两个循环，则有很大讲究。我在测试中有些很有意思的情况，见附录。最后得出的结论是：</p>\n<ul>\n<li><p>如果是循环变量递增或递减，不要单独对循环变量赋值，应该在它最后一次读取的时候使用嵌套的<code>++</code>或<code>--</code>操作符。</p>\n</li>\n<li><p>如果要与数组的长度作比较，应该事先把数组的length属性放入一个局部变量中，减少查询次数。</p>\n</li>\n</ul>\n<p>举例，假设arr是一个数组，最佳的遍历元素方式为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for(var i=0, len = arr.length;i&lt;len;i++)&#123;...&#125;</span><br></pre></td></tr></table></figure>\n\n<p>或者，如果无所谓顺序的话：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for(var i=arr.length;i&gt;0;i--)&#123;...&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"局部变量和全局变量\"><a href=\"#局部变量和全局变量\" class=\"headerlink\" title=\"局部变量和全局变量\"></a>局部变量和全局变量</h2><p>局部变量的速度要比全局变量的访问速度更快，因为全局变量其实是全局对象的成员，而局部变量是放在函数的栈当中的。</p>\n<h2 id=\"不使用Eval\"><a href=\"#不使用Eval\" class=\"headerlink\" title=\"不使用Eval\"></a>不使用Eval</h2><p>使用<code>eval</code>相当于在运行时再次调用解释引擎对内容进行运行，需要消耗大量时间。这时候使用JavaScript所支持的闭包可以实现函数模版（关于闭包的内容请参考函数式编程的有关内容）</p>\n<h2 id=\"减少对象查找\"><a href=\"#减少对象查找\" class=\"headerlink\" title=\"减少对象查找\"></a>减少对象查找</h2><p>因为JavaScript的解释性，所以<code>a.b.c.d.e</code>，需要进行至少4次查询操作，先检查a再检查a中的b，再检查b中的c，如此往下。所以如果这样的表达式重复出现，只要可能，应该尽量少出现这样的表达式，可以利用局部变量，把它放入一个临时的地方进行查询。</p>\n<p>这一点可以和循环结合起来，因为我们常常要根据字符串、数组的长度进行循环，而通常这个长度是不变的，比如每次查询<code>a.length</code>，就要额外进行一个操作，而预先把<code>var   len=a.length</code>，则就少了一次查询。</p>\n<h2 id=\"字符串连接\"><a href=\"#字符串连接\" class=\"headerlink\" title=\"字符串连接\"></a>字符串连接</h2><p>如果是追加字符串，最好使用<code>s+=anotherStr</code>操作，而不是要使用<code>s=s+anotherStr</code>。</p>\n<p>如果要连接多个字符串，应该少使用+&#x3D;，如</p>\n<p>s+&#x3D;a;<br>s+&#x3D;b;<br>s+&#x3D;c;</p>\n<p>应该写成</p>\n<p>s+&#x3D;a + b + c；</p>\n<p>而如果是收集字符串，比如多次对同一个字符串进行+&#x3D;操作的话，最好使用一个缓存。怎么用呢？使用JavaScript数组来收集，最后使用join方法连接起来，如下</p>\n<p>var buf &#x3D; new Array();<br>for(var i &#x3D; 0; i &lt; 100; i++){<br>       buf.push(i.toString());<br>}<br>var all &#x3D; buf.join(“”);</p>\n<h2 id=\"类型转换\"><a href=\"#类型转换\" class=\"headerlink\" title=\"类型转换\"></a>类型转换</h2><p>类型转换是大家常犯的错误，因为JavaScript是动态类型语言，你不能指定变量的类型。</p>\n<ol>\n<li>把数字转换成字符串，应用<code>&quot;&quot; + 1</code>，虽然看起来比较丑一点，但事实上这个效率是最高的，性能上来说：</li>\n</ol>\n<p><code>(&quot;&quot; + ) &gt; String() &gt; .toString() &gt; new String()</code></p>\n<p>这条其实和下面的”直接量”有点类似，尽量使用编译时就能使用的内部操作要比运行时使用的用户操作要快。</p>\n<p><code>String()</code>属于内部函数，所以速度很快，而<code>.toString()</code>要查询原型中的函数，所以速度逊色一些，<code>new String()</code>用于返回一个精确的副本。</p>\n<ol start=\"2\">\n<li>浮点数转换成整型，这个更容易出错，很多人喜欢使用<code>parseInt()</code>，其实<code>parseInt()</code>是用于将字符串转换成数字，而不是浮点数和整型之间的转换，我们应该使用<code>Math.floor()</code>或者<code>Math.round()</code>。</li>\n</ol>\n<p>另外，和第二节的对象查找中的问题不一样，<code>Math</code>是内部对象，所以<code>Math.floor()</code>其实并没有多少查询方法和调用的时间，速度是最快的。</p>\n<ol start=\"3\">\n<li>对于自定义的对象，如果定义了<code>toString()</code>方法来进行类型转换的话，推荐显式调用<code>toString()</code>，因为内部的操作在尝试所有可能性之后，会尝试对象的toString()方法尝试能否转化为String，所以直接调用这个方法效率会更高</li>\n</ol>\n<h2 id=\"使用直接量\"><a href=\"#使用直接量\" class=\"headerlink\" title=\"使用直接量\"></a>使用直接量</h2><p>其实这个影响倒比较小，可以忽略。什么叫使用直接量，比如，JavaScript支持使用<code>[param,param,param,...]</code>来直接表达一个数组，以往我们都使用<code>new Array(param,param,...)</code>，使用前者是引擎直接解释的，后者要调用一个<code>Array</code>内部构造器，所以要略微快一点点。</p>\n<p>同样，<code>var foo = &#123;&#125;</code>的方式也比<code>var foo = new Object();</code>快，<code>var reg = /../;</code>要比<code>var reg=new RegExp()</code>快。</p>\n<h2 id=\"字符串遍历操作\"><a href=\"#字符串遍历操作\" class=\"headerlink\" title=\"字符串遍历操作\"></a>字符串遍历操作</h2><p>对字符串进行循环操作，譬如替换、查找，应使用正则表达式，因为本身JavaScript的循环速度就比较慢，而正则表达式的操作是用C写成的语言的API，性能很好。</p>\n<h2 id=\"高级对象\"><a href=\"#高级对象\" class=\"headerlink\" title=\"高级对象\"></a>高级对象</h2><p>自定义高级对象和<code>Date</code>、<code>RegExp</code>对象在构造时都会消耗大量时间。如果可以复用，应采用缓存的方式。</p>\n<h1 id=\"DOM相关\"><a href=\"#DOM相关\" class=\"headerlink\" title=\"DOM相关\"></a>DOM相关</h1><h2 id=\"插入HTML\"><a href=\"#插入HTML\" class=\"headerlink\" title=\"插入HTML\"></a>插入HTML</h2><p>很多人喜欢在JavaScript中使用<code>document.write</code>来给页面生成内容。事实上这样的效率较低，如果需要直接插入HTML，可以找一个容器元素，比如指定一个div或者span，并设置他们的<code>innerHTML</code>来将自己的HTML代码插入到页面中。</p>\n<h2 id=\"对象查询\"><a href=\"#对象查询\" class=\"headerlink\" title=\"对象查询\"></a>对象查询</h2><p>使用<code>[&quot;&quot;]</code>查询要比<code>.items()</code>更快，这和前面的减少对象查找的思路是一样的，调用<code>.items()</code>增加了一次查询和函数的调用。</p>\n<h2 id=\"创建DOM节点\"><a href=\"#创建DOM节点\" class=\"headerlink\" title=\"创建DOM节点\"></a>创建DOM节点</h2><p>通常我们可能会使用字符串直接写HTML来创建节点，其实这样做</p>\n<ol>\n<li><p>无法保证代码的有效性</p>\n</li>\n<li><p>字符串操作效率低</p>\n</li>\n</ol>\n<p>所以应该是用<code>document.createElement()</code>方法，而如果文档中存在现成的样板节点，应该是用<code>cloneNode()</code>方法，因为使用<code>createElement()</code>方法之后，你需要设置多次元素的属性，使用<code>cloneNode()</code>则可以减少属性的设置次数–同样如果需要创建很多元素，应该先准备一个样板节点。</p>\n<h2 id=\"定时器\"><a href=\"#定时器\" class=\"headerlink\" title=\"定时器\"></a>定时器</h2><p>如果针对的是不断运行的代码，不应该使用<code>setTimeout</code>，而应该是用<code>setInterval</code>。<code>setTimeout</code>每次要重新设置一个定时器。</p>\n<h1 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h1><h2 id=\"脚本引擎\"><a href=\"#脚本引擎\" class=\"headerlink\" title=\"脚本引擎\"></a>脚本引擎</h2><p>据我测试Microsoft的JScript的效率较Mozilla的Spidermonkey要差很多，无论是执行速度还是内存管理上，因为JScript现在基本也不更新了。但SpiderMonkey不能使用<code>ActiveXObject</code></p>\n<h2 id=\"文件优化\"><a href=\"#文件优化\" class=\"headerlink\" title=\"文件优化\"></a>文件优化</h2><p>文件优化也是一个很有效的手段，删除所有的空格和注释，把代码放入一行内，可以加快下载的速度，注意，是下载的速度而不是解析的速度，如果是本地，注释和空格并不会影响解释和执行速度。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>本文总结了我在JavaScript编程中所找到的提高JavaScript运行性能的一些方法，其实这些经验都基于几条原则：</p>\n<ol>\n<li><p>直接拿手头现成的东西比较快，如局部变量比全局变量快，直接量比运行时构造对象快等等。</p>\n</li>\n<li><p>尽可能少地减少执行次数，比如先缓存需要多次查询的。</p>\n</li>\n<li><p>尽可能使用语言内置的功能，比如串链接。</p>\n</li>\n<li><p>尽可能使用系统提供的API，因为这些API是编译好的二进制代码，执行效率很高</p>\n</li>\n</ol>\n<p>同时，一些基本的算法上的优化，同样可以用在JavaScript中，比如运算结构的调整，这里就不再赘述了。但是由于JavaScript是解释型的，一般不会在运行时对字节码进行优化，所以这些优化仍然是很重要的。</p>\n<p>当然，其实这里的一些技巧同样使用在其他的一些解释型语言中，大家也可以进行参考。</p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><ul>\n<li><p><a href=\"http://www.umsu.de/jsperf/\">http://www.umsu.de/jsperf/</a> 各种浏览器的测试对比</p>\n</li>\n<li><p><a href=\"http://home.earthlink.net/~kendrasg/info/js_opt/\">http://home.earthlink.net/~kendrasg&#x2F;info&#x2F;js_opt&#x2F;</a></p>\n</li>\n</ul>\n<h1 id=\"附录1\"><a href=\"#附录1\" class=\"headerlink\" title=\"附录1\"></a>附录1</h1><p>由于是以前做过的测试，测试代码已经不全，我补充了一部分如下：</p>\n<p>var print;</p>\n<p>if(typeof document !&#x3D; “undefined” ){<br>    print &#x3D; function(){<br>                document.write(arguments[0]);<br>        }<br>}else if(typeof WScript !&#x3D; “undefined” ){<br>    print &#x3D; function(){<br>        WScript.Echo(arguments[0],arguments[1],arguments[2]);<br>    }<br>}</p>\n<p>function empty(){<br>}</p>\n<p>function benchmark(f){<br>    var i &#x3D; 0;<br>    var start &#x3D; (new Date()).getTime();</p>\n<pre><code>while(i &lt; pressure)&#123;\n    f(i++);\n&#125;\nvar end = (new Date()).getTime();\nWScript.Echo(end-start);\n</code></pre>\n<p>}</p>\n<p>&#x2F;*<br>i&#x3D;0<br>start &#x3D; (new Date()).getTime();<br>while(i &lt; 60000){<br>    c &#x3D; [i,i,i,i,i,i,i,i,i,i];<br>    i++;<br>}<br>end &#x3D; (new Date()).getTime();<br>WScript.Echo(end-start);<br>i&#x3D;0<br>start &#x3D; (new Date()).getTime();<br>while(i &lt; 60000){<br>    c &#x3D; new Array(i,i,i,i,i,i,i,i,i,i);<br>    i++;<br>}<br>var end &#x3D; (new Date()).getTime();<br>WScript.Echo(end-start);<br>*&#x2F;</p>\n<p>function internCast(i){<br>    return “” + i;<br>}</p>\n<p>function StringCast(i){<br>    return String(i)<br>}<br>function newStringCast(i){<br>    return new String(i)<br>}<br>function toStringCast(i){<br>    return i.toString();<br>}<br>function ParseInt(){<br>    return parseInt(j);<br>}<br>function MathFloor(){<br>    return Math.floor(j);<br>}<br>function Floor(){<br>    return floor(j);<br>}<br>var pressure &#x3D; 50000;<br>var a  &#x3D; “”;<br>var floor &#x3D; Math.floor;<br>j &#x3D; 123.123;<br>print(“————-\\nString Conversion Test”);<br>print(“The empty:”, benchmark(empty));<br>print(“intern:”, benchmark(internCast));<br>print(“String:”);<br>benchmark(StringCast);<br>print(“new String:”);<br>benchmark(newStringCast);<br>print(“toString:”);<br>benchmark(toStringCast);<br>print(“————-\\nFloat to Int Conversion Test”);<br>print(“parseInt”);<br>benchmark(ParseInt);<br>print(“Math.floor”);<br>benchmark(MathFloor);<br>print(“floor”)<br>benchmark(Floor);</p>\n<p>function newObject(){<br>    return new Object();<br>}</p>\n<p>function internObject(){<br>    return {};<br>}<br>print(“————\\nliteral Test”);<br>print(“runtime new object”, benchmark(newObject));<br>print(“literal object”, benchmark(internObject));</p>\n<h1 id=\"附录2\"><a href=\"#附录2\" class=\"headerlink\" title=\"附录2\"></a>附录2</h1><p>代码1：</p>\n<pre><code>for(var i=0;i&lt;100;i++)&#123;\n    arr\\[i\\]=0;\n&#125;\n</code></pre>\n<p>代码2：</p>\n<pre><code>var i = 0;\nwhile(i &lt; 100)&#123;\n    arr\\[i++\\]=0;\n&#125;\n</code></pre>\n<p>代码3：</p>\n<pre><code>var i = 0;\nwhile(i &lt; 100)&#123;\n    arr\\[i\\]=0;\n    i++;\n&#125;\n</code></pre>\n<p>在firefox下测试这两段代码，结果是代码2优于代码1和3，而代码1一般优于代码3，有时会被代码3超过；而在IE<br>6.0下，测试压力较大的时候（如测试10000次以上）代码2和3则有时候优于代码1，有时候就会远远落后代码1，而在测试压力较小（如5000次），则代码2&gt;代码3&gt;代码1。</p>\n<p>代码4：</p>\n<pre><code>var i = 0;\nvar a;\nwhile(i &lt; 100)&#123;\n    a = 0;\n    i++;\n&#125;\n</code></pre>\n<p>代码5：</p>\n<pre><code>var a;\nfor(var i=0;i&lt;100;i++)&#123;\n    a = 0;\n&#125;\n</code></pre>\n<p>上面两段代码在Firefox和IE下测试结果都是性能接近的。</p>\n<p>代码6：</p>\n<pre><code>var a;\nvar i=0;\nwhile(i&lt;100)&#123;\n    a=i;\n    i++;\n&#125;\n</code></pre>\n<p>代码7：</p>\n<pre><code>var a;\nvar i=0;\nwhile(i&lt;100)&#123;\n    a=i++;\n&#125;\n</code></pre>\n<p>代码8：</p>\n<pre><code>var a;\nfor(var i=0;i&lt;100;i++)&#123;\n    a = i;\n&#125;\n</code></pre>\n<p>代码9：</p>\n<pre><code>var a;\nfor(var i=0;i&lt;100;)&#123;\n    a = i++;\n&#125;\n</code></pre>\n<p>这四段代码在Firefox下6和8的性能接近，7和9的性能接近，而6,<br>8 &lt; 7, 9；</p>\n<p>最后我们来看一下空循环</p>\n<p>代码10：</p>\n<pre><code>for(var i=0;i&lt;100;i++)&#123;   &#125;\n</code></pre>\n<p>代码11：</p>\n<pre><code>var i;\nwhile(i&lt;100)&#123;        i++;    &#125;\n</code></pre>\n<p>最后的测试出现了神奇的结果，Firefox下代码10所花的时间与代码11所花的大约是24:1。所以它不具备参考价值，于是我没有放在一开始给大家看。</p>\n","more":"<p>如何优化JavaScript脚本的性能 作者：ShiningRay @ Nirvana Studio 随着网络的发展，网速和机器速度的提高，越来越多的网站用到了丰富客户端技术。而现在Ajax则是最为流行的一种方式。JavaScript是一种解释型语言，所以能无法达到和C&#x2F;Java之类的水平，限制了它能在客户端所做的事情，为了能改进他的性能，我想基于我以前给JavaScript做过的很多测试来谈谈…</p>\n<!-- more -->\n<h2 id=\"如何优化JavaScript脚本的性能\"><a href=\"#如何优化JavaScript脚本的性能\" class=\"headerlink\" title=\"如何优化JavaScript脚本的性能\"></a>如何优化JavaScript脚本的性能</h2><p>作者：ShiningRay @ <a href=\"http://www.nirvanastudio.org/\">Nirvana Studio</a></p>\n<p>随着网络的发展，网速和机器速度的提高，越来越多的网站用到了丰富客户端技术。而现在Ajax则是最为流行的一种方式。JavaScript是一种解释型语言，所以能无法达到和C&#x2F;Java之类的水平，限制了它能在客户端所做的事情，为了能改进他的性能，我想基于我以前给JavaScript做过的很多测试来谈谈自己的经验，希望能帮助大家改进自己的JavaScript脚本性能。</p>\n<h1 id=\"语言层次方面\"><a href=\"#语言层次方面\" class=\"headerlink\" title=\"语言层次方面\"></a>语言层次方面</h1><h2 id=\"循环\"><a href=\"#循环\" class=\"headerlink\" title=\"循环\"></a>循环</h2><p>循环是很常用的一个控制结构，大部分东西要依靠它来完成，在JavaScript中，我们可以使用<code>for(;;),while(),for(in)</code>三种循环，事实上，这三种循环中<code>for(in)</code>的效率极差，因为他需要查询散列键，只要可以就应该尽量少用。<code>for(;;)</code>和<code>while</code>循环的性能应该说基本（平时使用时）等价。</p>\n<p>而事实上，如何使用这两个循环，则有很大讲究。我在测试中有些很有意思的情况，见附录。最后得出的结论是：</p>\n<ul>\n<li><p>如果是循环变量递增或递减，不要单独对循环变量赋值，应该在它最后一次读取的时候使用嵌套的<code>++</code>或<code>--</code>操作符。</p>\n</li>\n<li><p>如果要与数组的长度作比较，应该事先把数组的length属性放入一个局部变量中，减少查询次数。</p>\n</li>\n</ul>\n<p>举例，假设arr是一个数组，最佳的遍历元素方式为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for(var i=0, len = arr.length;i&lt;len;i++)&#123;...&#125;</span><br></pre></td></tr></table></figure>\n\n<p>或者，如果无所谓顺序的话：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for(var i=arr.length;i&gt;0;i--)&#123;...&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"局部变量和全局变量\"><a href=\"#局部变量和全局变量\" class=\"headerlink\" title=\"局部变量和全局变量\"></a>局部变量和全局变量</h2><p>局部变量的速度要比全局变量的访问速度更快，因为全局变量其实是全局对象的成员，而局部变量是放在函数的栈当中的。</p>\n<h2 id=\"不使用Eval\"><a href=\"#不使用Eval\" class=\"headerlink\" title=\"不使用Eval\"></a>不使用Eval</h2><p>使用<code>eval</code>相当于在运行时再次调用解释引擎对内容进行运行，需要消耗大量时间。这时候使用JavaScript所支持的闭包可以实现函数模版（关于闭包的内容请参考函数式编程的有关内容）</p>\n<h2 id=\"减少对象查找\"><a href=\"#减少对象查找\" class=\"headerlink\" title=\"减少对象查找\"></a>减少对象查找</h2><p>因为JavaScript的解释性，所以<code>a.b.c.d.e</code>，需要进行至少4次查询操作，先检查a再检查a中的b，再检查b中的c，如此往下。所以如果这样的表达式重复出现，只要可能，应该尽量少出现这样的表达式，可以利用局部变量，把它放入一个临时的地方进行查询。</p>\n<p>这一点可以和循环结合起来，因为我们常常要根据字符串、数组的长度进行循环，而通常这个长度是不变的，比如每次查询<code>a.length</code>，就要额外进行一个操作，而预先把<code>var   len=a.length</code>，则就少了一次查询。</p>\n<h2 id=\"字符串连接\"><a href=\"#字符串连接\" class=\"headerlink\" title=\"字符串连接\"></a>字符串连接</h2><p>如果是追加字符串，最好使用<code>s+=anotherStr</code>操作，而不是要使用<code>s=s+anotherStr</code>。</p>\n<p>如果要连接多个字符串，应该少使用+&#x3D;，如</p>\n<p>s+&#x3D;a;<br>s+&#x3D;b;<br>s+&#x3D;c;</p>\n<p>应该写成</p>\n<p>s+&#x3D;a + b + c；</p>\n<p>而如果是收集字符串，比如多次对同一个字符串进行+&#x3D;操作的话，最好使用一个缓存。怎么用呢？使用JavaScript数组来收集，最后使用join方法连接起来，如下</p>\n<p>var buf &#x3D; new Array();<br>for(var i &#x3D; 0; i &lt; 100; i++){<br>       buf.push(i.toString());<br>}<br>var all &#x3D; buf.join(“”);</p>\n<h2 id=\"类型转换\"><a href=\"#类型转换\" class=\"headerlink\" title=\"类型转换\"></a>类型转换</h2><p>类型转换是大家常犯的错误，因为JavaScript是动态类型语言，你不能指定变量的类型。</p>\n<ol>\n<li>把数字转换成字符串，应用<code>&quot;&quot; + 1</code>，虽然看起来比较丑一点，但事实上这个效率是最高的，性能上来说：</li>\n</ol>\n<p><code>(&quot;&quot; + ) &gt; String() &gt; .toString() &gt; new String()</code></p>\n<p>这条其实和下面的”直接量”有点类似，尽量使用编译时就能使用的内部操作要比运行时使用的用户操作要快。</p>\n<p><code>String()</code>属于内部函数，所以速度很快，而<code>.toString()</code>要查询原型中的函数，所以速度逊色一些，<code>new String()</code>用于返回一个精确的副本。</p>\n<ol start=\"2\">\n<li>浮点数转换成整型，这个更容易出错，很多人喜欢使用<code>parseInt()</code>，其实<code>parseInt()</code>是用于将字符串转换成数字，而不是浮点数和整型之间的转换，我们应该使用<code>Math.floor()</code>或者<code>Math.round()</code>。</li>\n</ol>\n<p>另外，和第二节的对象查找中的问题不一样，<code>Math</code>是内部对象，所以<code>Math.floor()</code>其实并没有多少查询方法和调用的时间，速度是最快的。</p>\n<ol start=\"3\">\n<li>对于自定义的对象，如果定义了<code>toString()</code>方法来进行类型转换的话，推荐显式调用<code>toString()</code>，因为内部的操作在尝试所有可能性之后，会尝试对象的toString()方法尝试能否转化为String，所以直接调用这个方法效率会更高</li>\n</ol>\n<h2 id=\"使用直接量\"><a href=\"#使用直接量\" class=\"headerlink\" title=\"使用直接量\"></a>使用直接量</h2><p>其实这个影响倒比较小，可以忽略。什么叫使用直接量，比如，JavaScript支持使用<code>[param,param,param,...]</code>来直接表达一个数组，以往我们都使用<code>new Array(param,param,...)</code>，使用前者是引擎直接解释的，后者要调用一个<code>Array</code>内部构造器，所以要略微快一点点。</p>\n<p>同样，<code>var foo = &#123;&#125;</code>的方式也比<code>var foo = new Object();</code>快，<code>var reg = /../;</code>要比<code>var reg=new RegExp()</code>快。</p>\n<h2 id=\"字符串遍历操作\"><a href=\"#字符串遍历操作\" class=\"headerlink\" title=\"字符串遍历操作\"></a>字符串遍历操作</h2><p>对字符串进行循环操作，譬如替换、查找，应使用正则表达式，因为本身JavaScript的循环速度就比较慢，而正则表达式的操作是用C写成的语言的API，性能很好。</p>\n<h2 id=\"高级对象\"><a href=\"#高级对象\" class=\"headerlink\" title=\"高级对象\"></a>高级对象</h2><p>自定义高级对象和<code>Date</code>、<code>RegExp</code>对象在构造时都会消耗大量时间。如果可以复用，应采用缓存的方式。</p>\n<h1 id=\"DOM相关\"><a href=\"#DOM相关\" class=\"headerlink\" title=\"DOM相关\"></a>DOM相关</h1><h2 id=\"插入HTML\"><a href=\"#插入HTML\" class=\"headerlink\" title=\"插入HTML\"></a>插入HTML</h2><p>很多人喜欢在JavaScript中使用<code>document.write</code>来给页面生成内容。事实上这样的效率较低，如果需要直接插入HTML，可以找一个容器元素，比如指定一个div或者span，并设置他们的<code>innerHTML</code>来将自己的HTML代码插入到页面中。</p>\n<h2 id=\"对象查询\"><a href=\"#对象查询\" class=\"headerlink\" title=\"对象查询\"></a>对象查询</h2><p>使用<code>[&quot;&quot;]</code>查询要比<code>.items()</code>更快，这和前面的减少对象查找的思路是一样的，调用<code>.items()</code>增加了一次查询和函数的调用。</p>\n<h2 id=\"创建DOM节点\"><a href=\"#创建DOM节点\" class=\"headerlink\" title=\"创建DOM节点\"></a>创建DOM节点</h2><p>通常我们可能会使用字符串直接写HTML来创建节点，其实这样做</p>\n<ol>\n<li><p>无法保证代码的有效性</p>\n</li>\n<li><p>字符串操作效率低</p>\n</li>\n</ol>\n<p>所以应该是用<code>document.createElement()</code>方法，而如果文档中存在现成的样板节点，应该是用<code>cloneNode()</code>方法，因为使用<code>createElement()</code>方法之后，你需要设置多次元素的属性，使用<code>cloneNode()</code>则可以减少属性的设置次数–同样如果需要创建很多元素，应该先准备一个样板节点。</p>\n<h2 id=\"定时器\"><a href=\"#定时器\" class=\"headerlink\" title=\"定时器\"></a>定时器</h2><p>如果针对的是不断运行的代码，不应该使用<code>setTimeout</code>，而应该是用<code>setInterval</code>。<code>setTimeout</code>每次要重新设置一个定时器。</p>\n<h1 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h1><h2 id=\"脚本引擎\"><a href=\"#脚本引擎\" class=\"headerlink\" title=\"脚本引擎\"></a>脚本引擎</h2><p>据我测试Microsoft的JScript的效率较Mozilla的Spidermonkey要差很多，无论是执行速度还是内存管理上，因为JScript现在基本也不更新了。但SpiderMonkey不能使用<code>ActiveXObject</code></p>\n<h2 id=\"文件优化\"><a href=\"#文件优化\" class=\"headerlink\" title=\"文件优化\"></a>文件优化</h2><p>文件优化也是一个很有效的手段，删除所有的空格和注释，把代码放入一行内，可以加快下载的速度，注意，是下载的速度而不是解析的速度，如果是本地，注释和空格并不会影响解释和执行速度。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>本文总结了我在JavaScript编程中所找到的提高JavaScript运行性能的一些方法，其实这些经验都基于几条原则：</p>\n<ol>\n<li><p>直接拿手头现成的东西比较快，如局部变量比全局变量快，直接量比运行时构造对象快等等。</p>\n</li>\n<li><p>尽可能少地减少执行次数，比如先缓存需要多次查询的。</p>\n</li>\n<li><p>尽可能使用语言内置的功能，比如串链接。</p>\n</li>\n<li><p>尽可能使用系统提供的API，因为这些API是编译好的二进制代码，执行效率很高</p>\n</li>\n</ol>\n<p>同时，一些基本的算法上的优化，同样可以用在JavaScript中，比如运算结构的调整，这里就不再赘述了。但是由于JavaScript是解释型的，一般不会在运行时对字节码进行优化，所以这些优化仍然是很重要的。</p>\n<p>当然，其实这里的一些技巧同样使用在其他的一些解释型语言中，大家也可以进行参考。</p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><ul>\n<li><p><a href=\"http://www.umsu.de/jsperf/\">http://www.umsu.de/jsperf/</a> 各种浏览器的测试对比</p>\n</li>\n<li><p><a href=\"http://home.earthlink.net/~kendrasg/info/js_opt/\">http://home.earthlink.net/~kendrasg&#x2F;info&#x2F;js_opt&#x2F;</a></p>\n</li>\n</ul>\n<h1 id=\"附录1\"><a href=\"#附录1\" class=\"headerlink\" title=\"附录1\"></a>附录1</h1><p>由于是以前做过的测试，测试代码已经不全，我补充了一部分如下：</p>\n<p>var print;</p>\n<p>if(typeof document !&#x3D; “undefined” ){<br>    print &#x3D; function(){<br>                document.write(arguments[0]);<br>        }<br>}else if(typeof WScript !&#x3D; “undefined” ){<br>    print &#x3D; function(){<br>        WScript.Echo(arguments[0],arguments[1],arguments[2]);<br>    }<br>}</p>\n<p>function empty(){<br>}</p>\n<p>function benchmark(f){<br>    var i &#x3D; 0;<br>    var start &#x3D; (new Date()).getTime();</p>\n<pre><code>while(i &lt; pressure)&#123;\n    f(i++);\n&#125;\nvar end = (new Date()).getTime();\nWScript.Echo(end-start);\n</code></pre>\n<p>}</p>\n<p>&#x2F;*<br>i&#x3D;0<br>start &#x3D; (new Date()).getTime();<br>while(i &lt; 60000){<br>    c &#x3D; [i,i,i,i,i,i,i,i,i,i];<br>    i++;<br>}<br>end &#x3D; (new Date()).getTime();<br>WScript.Echo(end-start);<br>i&#x3D;0<br>start &#x3D; (new Date()).getTime();<br>while(i &lt; 60000){<br>    c &#x3D; new Array(i,i,i,i,i,i,i,i,i,i);<br>    i++;<br>}<br>var end &#x3D; (new Date()).getTime();<br>WScript.Echo(end-start);<br>*&#x2F;</p>\n<p>function internCast(i){<br>    return “” + i;<br>}</p>\n<p>function StringCast(i){<br>    return String(i)<br>}<br>function newStringCast(i){<br>    return new String(i)<br>}<br>function toStringCast(i){<br>    return i.toString();<br>}<br>function ParseInt(){<br>    return parseInt(j);<br>}<br>function MathFloor(){<br>    return Math.floor(j);<br>}<br>function Floor(){<br>    return floor(j);<br>}<br>var pressure &#x3D; 50000;<br>var a  &#x3D; “”;<br>var floor &#x3D; Math.floor;<br>j &#x3D; 123.123;<br>print(“————-\\nString Conversion Test”);<br>print(“The empty:”, benchmark(empty));<br>print(“intern:”, benchmark(internCast));<br>print(“String:”);<br>benchmark(StringCast);<br>print(“new String:”);<br>benchmark(newStringCast);<br>print(“toString:”);<br>benchmark(toStringCast);<br>print(“————-\\nFloat to Int Conversion Test”);<br>print(“parseInt”);<br>benchmark(ParseInt);<br>print(“Math.floor”);<br>benchmark(MathFloor);<br>print(“floor”)<br>benchmark(Floor);</p>\n<p>function newObject(){<br>    return new Object();<br>}</p>\n<p>function internObject(){<br>    return {};<br>}<br>print(“————\\nliteral Test”);<br>print(“runtime new object”, benchmark(newObject));<br>print(“literal object”, benchmark(internObject));</p>\n<h1 id=\"附录2\"><a href=\"#附录2\" class=\"headerlink\" title=\"附录2\"></a>附录2</h1><p>代码1：</p>\n<pre><code>for(var i=0;i&lt;100;i++)&#123;\n    arr\\[i\\]=0;\n&#125;\n</code></pre>\n<p>代码2：</p>\n<pre><code>var i = 0;\nwhile(i &lt; 100)&#123;\n    arr\\[i++\\]=0;\n&#125;\n</code></pre>\n<p>代码3：</p>\n<pre><code>var i = 0;\nwhile(i &lt; 100)&#123;\n    arr\\[i\\]=0;\n    i++;\n&#125;\n</code></pre>\n<p>在firefox下测试这两段代码，结果是代码2优于代码1和3，而代码1一般优于代码3，有时会被代码3超过；而在IE<br>6.0下，测试压力较大的时候（如测试10000次以上）代码2和3则有时候优于代码1，有时候就会远远落后代码1，而在测试压力较小（如5000次），则代码2&gt;代码3&gt;代码1。</p>\n<p>代码4：</p>\n<pre><code>var i = 0;\nvar a;\nwhile(i &lt; 100)&#123;\n    a = 0;\n    i++;\n&#125;\n</code></pre>\n<p>代码5：</p>\n<pre><code>var a;\nfor(var i=0;i&lt;100;i++)&#123;\n    a = 0;\n&#125;\n</code></pre>\n<p>上面两段代码在Firefox和IE下测试结果都是性能接近的。</p>\n<p>代码6：</p>\n<pre><code>var a;\nvar i=0;\nwhile(i&lt;100)&#123;\n    a=i;\n    i++;\n&#125;\n</code></pre>\n<p>代码7：</p>\n<pre><code>var a;\nvar i=0;\nwhile(i&lt;100)&#123;\n    a=i++;\n&#125;\n</code></pre>\n<p>代码8：</p>\n<pre><code>var a;\nfor(var i=0;i&lt;100;i++)&#123;\n    a = i;\n&#125;\n</code></pre>\n<p>代码9：</p>\n<pre><code>var a;\nfor(var i=0;i&lt;100;)&#123;\n    a = i++;\n&#125;\n</code></pre>\n<p>这四段代码在Firefox下6和8的性能接近，7和9的性能接近，而6,<br>8 &lt; 7, 9；</p>\n<p>最后我们来看一下空循环</p>\n<p>代码10：</p>\n<pre><code>for(var i=0;i&lt;100;i++)&#123;   &#125;\n</code></pre>\n<p>代码11：</p>\n<pre><code>var i;\nwhile(i&lt;100)&#123;        i++;    &#125;\n</code></pre>\n<p>最后的测试出现了神奇的结果，Firefox下代码10所花的时间与代码11所花的大约是24:1。所以它不具备参考价值，于是我没有放在一开始给大家看。</p>\n","categories":[],"tags":[]}
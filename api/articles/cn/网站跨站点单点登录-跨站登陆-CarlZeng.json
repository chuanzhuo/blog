{"title":"网站跨站点单点登录-跨站登陆-CarlZeng","slug":"cn/网站跨站点单点登录-跨站登陆-CarlZeng","date":"2009-03-23T06:16:00.000Z","updated":"2023-10-02T02:27:28.970Z","comments":true,"path":"api/articles/cn/网站跨站点单点登录-跨站登陆-CarlZeng.json","excerpt":"昨天和几位朋友探讨到了这个话题，发现虽然单点登录，或者叫做独立的passport登录虽然已经有了很多实现方法，但是能真正了解并实现的人却并不太多，所以些下此文，希望从原理到实现，能让大家了解的多一些至于什么是单点登录，举个例子，如果你登录了msn messenger，访问hotmail邮件就不用在此登录。一般单点登录都需要有一个独立的登录站点,一般具有独立的域名，专门的进行注册，登录，注销等操作我...","covers":["http://images.cnblogs.com/cnblogs_com/yizhu2000/WindowsLiveWriter/3616c09558a3_136C8/login_thumb_1.gif","http://images.cnblogs.com/cnblogs_com/yizhu2000/WindowsLiveWriter/3616c09558a3_136C8/logout_thumb.gif"],"content":"<p>昨天和几位朋友探讨到了这个话题，发现虽然单点登录，或者叫做独立的passport登录虽然已经有了很多实现方法，但是能真正了解并实现的人却并不太多，所以些下此文，希望从原理到实现，能让大家了解的多一些至于什么是单点登录，举个例子，如果你登录了msn messenger，访问hotmail邮件就不用在此登录。一般单点登录都需要有一个独立的登录站点,一般具有独立的域名，专门的进行注册，登录，注销等操作我…</p>\n<!-- more -->\n<p>昨天和几位朋友探讨到了这个话题，发现虽然单点登录，或者叫做独立的passport登录虽然已经有了很多实现方法，但是能真正了解并实现的人却并不太多，所以些下此文，希望从原理到实现，能让大家了解的多一些</p>\n<p>至于什么是单点登录，举个例子，如果你登录了msn messenger，访问hotmail邮件就不用在此登录。<br>一般单点登录都需要有一个独立的登录站点,一般具有独立的域名，专门的进行注册，登录，注销等操作</p>\n<p>我们为了讨论方便，把这个登录站点叫做站点P，设其Url为<a href=\"http://passport.yizhu2000.com/\">http://passport.yizhu2000.com</a>，需要提供服务的站点设为A和B，跨站点单点登录是指你在A网站进行登录后，使用B网站的服务就不需要再登录</p>\n<p>从技术角度讲单点登录分为：</p>\n<ul>\n<li>跨子域单点登录</li>\n<li>完全跨单点域登录</li>\n</ul>\n<h2 id=\"跨子域单点登录\"><a href=\"#跨子域单点登录\" class=\"headerlink\" title=\"跨子域单点登录\"></a>跨子域单点登录</h2><p>所谓跨子域登录，A，B站点和P站点位于同一个域下面，比如A站点为<a href=\"http://blog.yizhu2000.com/\">http://blog.yizhu2000.com</a> B站点为 <a href=\"http://forum.yizhu2000.com/\">http://forum.yizhu2000.com</a>,他们和登录站点P的关系可以看到，都是属于同一个父域，yizhu2000.com,不同的是子域不同，一个为blog，一个为forum，一个是passport</p>\n<p>我们先看看最常用的非跨站点普通登录的情况，一般登录验证通过后，一般会将你的用户名和一些用户信息，通过某一密钥进行加密，写在本地，也就是一个加密的cookie，我们把这个cookie叫做–票（ticket）。</p>\n<p>需要判断用户是否登录的页面，需要读取这个ticket，并从其中解密出用户信息，如果ticket不存在，或者无法解密，意味着用户没有登录，或者登录信息不正确，这时就要跳转到登录页面进行登录，在这里加密的作用有两个，一是防止用户信息被不怀好意者看到，二是保证ticket不会被伪造，后者其实更为重要，加密后，各个应用需要采用与加密同样的密钥进行解密，如果不知道密钥，就不能伪造出ticket，</p>\n<p>（注：加密和解密的密钥有可能不同，取决于采用什么加密算法，如果是对称加密，则为同一密钥，如果是非对称，就不同了，一般用私钥加密，公钥解密，但是无论怎样，密钥都只有内部知道，这样伪造者既无法伪造也无法解密ticket）</p>\n<p>跨子域的单点登录，和上述普通登录的过程没有什么不同，唯一不同的是写cookie时，由于登录站点P和应用A处于不同的子域，P站写入的 cookie的域为passport.yizhu2000.net，而A站点为forum.yizhu2000.net，A在判断用户登录时无法读到P站点的ticket</p>\n<p>解决方法非常简单，当Login完成后P站点写ticket的时候，只需把cookie的域设为他们共同的父域，yizhu2000.net就可以了：cookie.domain&#x3D;”yizhu2000.net”，A站点自然就可以读到这个ticket了</p>\n<p>ASP。Net的form验证本身实现了这个机制，大家可以参考<a href=\"http://blog.csdn.net/octverve/archive/2007/09/22/1796338.aspx\">http://blog.csdn.net/octverve/archive/2007/09/22/1796338.aspx</a></p>\n<p><em>ASP.NET身份验证信息跨域共享状态</em></p>\n<p><em>在ASP.NET 2.0 中只需修改web.config文件即可，修改方法如下:</em></p>\n<p><em><authentication mode=\"Forms\"><br><forms name=\".ASPNETFORM\" domain=\"imneio.com\" loginUrl=\"/login.aspx\" defaultUrl=\"/default.aspx\" protection=\"All\" timeout=\"30\" path=\"/\" requireSSL=\"false\" slidingExpiration=\"true\" enableCrossAppRedirects=\"false\" cookieless=\"UseDeviceProfile\" /><br></authentication></em></p>\n<p><em>domain指定了cookie保存的域，只要保存的是 abc.com形式或者.abc.com的形式，那么其二级域名都可以共享此cookie。</em></p>\n<p><em>此外，web.config标签中的<sessionState >也做相应修改，mode改为StateServer或者SqlServer，那么里面的session信息也就全部可以共享了。</em></p>\n<p>_StateServer需要在服务中开启”asp.net状态服务”的服务_。</p>\n<p><a href=\"http://www.imneio.com/2007/11/17/aspnetnote1/\" title=\"http://www.imneio.com/2007/11/17/aspnetnote1/\">http://www.imneio.com/2007/11/17/aspnetnote1/</a>，以上斜体内容摘自此链接</p>\n<h2 id=\"完全跨单点域登录\"><a href=\"#完全跨单点域登录\" class=\"headerlink\" title=\"完全跨单点域登录\"></a>完全跨单点域登录</h2><p>完全跨域登录，是指A，B站点和P站点没有共同的父域，比如A站点为forum.yizhu1999.net,B站点为blog.yizhu1998.net，大家可以参考微软旗下的几个站点<a href=\"http://www.live.com/\" title=\"http://www.live.com\">http://www.live.com</a>，<a href=\"http://www.hotmail.com/\">www.hotmail.com</a>,这两个站点就没有共同的父域，而仍然可以共用登录，怎样才能实现呢？请参考下图，由于这种情况ticket比较复杂，我们暂时把P站点创建的的ticket叫做P-ticket，而A站点创建的ticket叫A-ticket，B的为B-ticket</p>\n<p><a href=\"http://images.cnblogs.com/cnblogs_com/yizhu2000/WindowsLiveWriter/3616c09558a3_136C8/login_4.gif\"><img data-src=\"http://images.cnblogs.com/cnblogs_com/yizhu2000/WindowsLiveWriter/3616c09558a3_136C8/login_thumb_1.gif\" alt=\"login\"></a></p>\n<p>由于站点A（forum.yizhu1999.com）不能读取到由站点P（passport.yizhu2000.com）创建的加密 ticket，所以当用户访问A站点上需要登录才能访问的资源时，A站点会首先查看是否有A-ticket，如果没有，证明用户没有在A站点登录过，不过并不保证用户没有在B站点登录，（重复一下，既然是单点登录，当然无论你在A，B任意一个站点登录过，另外一个站点都要可以访问），请求会被重定向到p站点的验证页面，验证页面读取P-ticket，如果没有，或者解密不成功，就需要重定向登录页面，登录页面完成登录后，写一个加密cookie，也就是 P-ticket，并且重定向到A站点的登录处理页，并把加密的用户信息作为参数传递给这个页面，这个页面接收登录页的用户信息，解密后也要写一个 cookie，也就是A-ticket，今后用户再次访问A站点上需要登录权限才能访问的资源时，只需要检查这个A-cookie是否存在就可以了</p>\n<p>当用户访问B站点时，会重复上面的过程，监测到没有B-ticket，就会重定向到P站点的验证页面，去检查P-ticket，如果没有，就登录，有则返回B的登录处理页面写B-ticket</p>\n<p>注销的时候需要删除P-ticket和A-ticket</p>\n<p><a href=\"http://images.cnblogs.com/cnblogs_com/yizhu2000/WindowsLiveWriter/3616c09558a3_136C8/logout.gif\"><img data-src=\"http://images.cnblogs.com/cnblogs_com/yizhu2000/WindowsLiveWriter/3616c09558a3_136C8/logout_thumb.gif\" alt=\"logout\"></a></p>\n<p>怎么删除cookie：本来以为这个不是问题，不过还是有朋友问道，简单的说其实是创建一个和你要删除的cookie同名的cookie，并把 cookie的expire设为当前时间之前的某个时间，不过在跨子域的删除cookie时有一点要注意：必须要把cookie的域设置为父域，在本文中为yizhu2000.com</p>\n<p>为了保证各个环节的传输的安全性，最好使用https连接</p>\n<p>来源：<a href=\"http://www.cnblogs.com/yizhu2000/archive/2008/04/01/1131976.html\">http://www.cnblogs.com/yizhu2000/archive/2008/04/01/1131976.html</a></p>\n","more":"<p>昨天和几位朋友探讨到了这个话题，发现虽然单点登录，或者叫做独立的passport登录虽然已经有了很多实现方法，但是能真正了解并实现的人却并不太多，所以些下此文，希望从原理到实现，能让大家了解的多一些至于什么是单点登录，举个例子，如果你登录了msn messenger，访问hotmail邮件就不用在此登录。一般单点登录都需要有一个独立的登录站点,一般具有独立的域名，专门的进行注册，登录，注销等操作我…</p>\n<!-- more -->\n<p>昨天和几位朋友探讨到了这个话题，发现虽然单点登录，或者叫做独立的passport登录虽然已经有了很多实现方法，但是能真正了解并实现的人却并不太多，所以些下此文，希望从原理到实现，能让大家了解的多一些</p>\n<p>至于什么是单点登录，举个例子，如果你登录了msn messenger，访问hotmail邮件就不用在此登录。<br>一般单点登录都需要有一个独立的登录站点,一般具有独立的域名，专门的进行注册，登录，注销等操作</p>\n<p>我们为了讨论方便，把这个登录站点叫做站点P，设其Url为<a href=\"http://passport.yizhu2000.com/\">http://passport.yizhu2000.com</a>，需要提供服务的站点设为A和B，跨站点单点登录是指你在A网站进行登录后，使用B网站的服务就不需要再登录</p>\n<p>从技术角度讲单点登录分为：</p>\n<ul>\n<li>跨子域单点登录</li>\n<li>完全跨单点域登录</li>\n</ul>\n<h2 id=\"跨子域单点登录\"><a href=\"#跨子域单点登录\" class=\"headerlink\" title=\"跨子域单点登录\"></a>跨子域单点登录</h2><p>所谓跨子域登录，A，B站点和P站点位于同一个域下面，比如A站点为<a href=\"http://blog.yizhu2000.com/\">http://blog.yizhu2000.com</a> B站点为 <a href=\"http://forum.yizhu2000.com/\">http://forum.yizhu2000.com</a>,他们和登录站点P的关系可以看到，都是属于同一个父域，yizhu2000.com,不同的是子域不同，一个为blog，一个为forum，一个是passport</p>\n<p>我们先看看最常用的非跨站点普通登录的情况，一般登录验证通过后，一般会将你的用户名和一些用户信息，通过某一密钥进行加密，写在本地，也就是一个加密的cookie，我们把这个cookie叫做–票（ticket）。</p>\n<p>需要判断用户是否登录的页面，需要读取这个ticket，并从其中解密出用户信息，如果ticket不存在，或者无法解密，意味着用户没有登录，或者登录信息不正确，这时就要跳转到登录页面进行登录，在这里加密的作用有两个，一是防止用户信息被不怀好意者看到，二是保证ticket不会被伪造，后者其实更为重要，加密后，各个应用需要采用与加密同样的密钥进行解密，如果不知道密钥，就不能伪造出ticket，</p>\n<p>（注：加密和解密的密钥有可能不同，取决于采用什么加密算法，如果是对称加密，则为同一密钥，如果是非对称，就不同了，一般用私钥加密，公钥解密，但是无论怎样，密钥都只有内部知道，这样伪造者既无法伪造也无法解密ticket）</p>\n<p>跨子域的单点登录，和上述普通登录的过程没有什么不同，唯一不同的是写cookie时，由于登录站点P和应用A处于不同的子域，P站写入的 cookie的域为passport.yizhu2000.net，而A站点为forum.yizhu2000.net，A在判断用户登录时无法读到P站点的ticket</p>\n<p>解决方法非常简单，当Login完成后P站点写ticket的时候，只需把cookie的域设为他们共同的父域，yizhu2000.net就可以了：cookie.domain&#x3D;”yizhu2000.net”，A站点自然就可以读到这个ticket了</p>\n<p>ASP。Net的form验证本身实现了这个机制，大家可以参考<a href=\"http://blog.csdn.net/octverve/archive/2007/09/22/1796338.aspx\">http://blog.csdn.net/octverve/archive/2007/09/22/1796338.aspx</a></p>\n<p><em>ASP.NET身份验证信息跨域共享状态</em></p>\n<p><em>在ASP.NET 2.0 中只需修改web.config文件即可，修改方法如下:</em></p>\n<p><em><authentication mode=\"Forms\"><br><forms name=\".ASPNETFORM\" domain=\"imneio.com\" loginUrl=\"/login.aspx\" defaultUrl=\"/default.aspx\" protection=\"All\" timeout=\"30\" path=\"/\" requireSSL=\"false\" slidingExpiration=\"true\" enableCrossAppRedirects=\"false\" cookieless=\"UseDeviceProfile\" /><br></authentication></em></p>\n<p><em>domain指定了cookie保存的域，只要保存的是 abc.com形式或者.abc.com的形式，那么其二级域名都可以共享此cookie。</em></p>\n<p><em>此外，web.config标签中的<sessionState >也做相应修改，mode改为StateServer或者SqlServer，那么里面的session信息也就全部可以共享了。</em></p>\n<p>_StateServer需要在服务中开启”asp.net状态服务”的服务_。</p>\n<p><a href=\"http://www.imneio.com/2007/11/17/aspnetnote1/\" title=\"http://www.imneio.com/2007/11/17/aspnetnote1/\">http://www.imneio.com/2007/11/17/aspnetnote1/</a>，以上斜体内容摘自此链接</p>\n<h2 id=\"完全跨单点域登录\"><a href=\"#完全跨单点域登录\" class=\"headerlink\" title=\"完全跨单点域登录\"></a>完全跨单点域登录</h2><p>完全跨域登录，是指A，B站点和P站点没有共同的父域，比如A站点为forum.yizhu1999.net,B站点为blog.yizhu1998.net，大家可以参考微软旗下的几个站点<a href=\"http://www.live.com/\" title=\"http://www.live.com\">http://www.live.com</a>，<a href=\"http://www.hotmail.com/\">www.hotmail.com</a>,这两个站点就没有共同的父域，而仍然可以共用登录，怎样才能实现呢？请参考下图，由于这种情况ticket比较复杂，我们暂时把P站点创建的的ticket叫做P-ticket，而A站点创建的ticket叫A-ticket，B的为B-ticket</p>\n<p><a href=\"http://images.cnblogs.com/cnblogs_com/yizhu2000/WindowsLiveWriter/3616c09558a3_136C8/login_4.gif\"><img data-src=\"http://images.cnblogs.com/cnblogs_com/yizhu2000/WindowsLiveWriter/3616c09558a3_136C8/login_thumb_1.gif\" alt=\"login\"></a></p>\n<p>由于站点A（forum.yizhu1999.com）不能读取到由站点P（passport.yizhu2000.com）创建的加密 ticket，所以当用户访问A站点上需要登录才能访问的资源时，A站点会首先查看是否有A-ticket，如果没有，证明用户没有在A站点登录过，不过并不保证用户没有在B站点登录，（重复一下，既然是单点登录，当然无论你在A，B任意一个站点登录过，另外一个站点都要可以访问），请求会被重定向到p站点的验证页面，验证页面读取P-ticket，如果没有，或者解密不成功，就需要重定向登录页面，登录页面完成登录后，写一个加密cookie，也就是 P-ticket，并且重定向到A站点的登录处理页，并把加密的用户信息作为参数传递给这个页面，这个页面接收登录页的用户信息，解密后也要写一个 cookie，也就是A-ticket，今后用户再次访问A站点上需要登录权限才能访问的资源时，只需要检查这个A-cookie是否存在就可以了</p>\n<p>当用户访问B站点时，会重复上面的过程，监测到没有B-ticket，就会重定向到P站点的验证页面，去检查P-ticket，如果没有，就登录，有则返回B的登录处理页面写B-ticket</p>\n<p>注销的时候需要删除P-ticket和A-ticket</p>\n<p><a href=\"http://images.cnblogs.com/cnblogs_com/yizhu2000/WindowsLiveWriter/3616c09558a3_136C8/logout.gif\"><img data-src=\"http://images.cnblogs.com/cnblogs_com/yizhu2000/WindowsLiveWriter/3616c09558a3_136C8/logout_thumb.gif\" alt=\"logout\"></a></p>\n<p>怎么删除cookie：本来以为这个不是问题，不过还是有朋友问道，简单的说其实是创建一个和你要删除的cookie同名的cookie，并把 cookie的expire设为当前时间之前的某个时间，不过在跨子域的删除cookie时有一点要注意：必须要把cookie的域设置为父域，在本文中为yizhu2000.com</p>\n<p>为了保证各个环节的传输的安全性，最好使用https连接</p>\n<p>来源：<a href=\"http://www.cnblogs.com/yizhu2000/archive/2008/04/01/1131976.html\">http://www.cnblogs.com/yizhu2000/archive/2008/04/01/1131976.html</a></p>\n","categories":[],"tags":[]}
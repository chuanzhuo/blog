{"title":"SQL Server 存储过程的经典分页-CarlZeng","slug":"SQL-Server-存储过程的经典分页-CarlZeng","date":"2009-05-26T00:56:00.000Z","updated":"2023-10-02T02:27:28.984Z","comments":true,"path":"api/articles/SQL-Server-存储过程的经典分页-CarlZeng.json","excerpt":"SQL Server 存储过程的经典分页关键字：分页,存储过程　建立表：CREATE TABLE [TestTable] ([ID] [int] IDENTITY (1, 1) NOT NULL ,[FirstName] [nvarchar] (100) COLLATE Chinese_PRC_CI_AS NULL ,[LastName] [nvarchar] (10...","covers":null,"content":"<p>SQL Server 存储过程的经典分页 关键字：分页,存储过程 　 建立表： CREATE TABLE [TestTable] ( [ID] [int] IDENTITY (1, 1) NOT NULL , [FirstName] [nvarchar] (100) COLLATE Chinese_PRC_CI_AS NULL , [LastName] [nvarchar] (10…</p>\n<!-- more -->\n<p>SQL Server 存储过程的经典分页  </p>\n<p>关键字：<strong>分页,存储过程</strong></p>\n<p>　</p>\n<p>建立表：  </p>\n<p>CREATE TABLE [TestTable] (<br>[ID] [int] IDENTITY (1, 1) NOT NULL ,<br>[FirstName] [nvarchar] (100) COLLATE Chinese_PRC_CI_AS NULL ,<br>[LastName] [nvarchar] (100) COLLATE Chinese_PRC_CI_AS NULL ,<br>[Country] [nvarchar] (50) COLLATE Chinese_PRC_CI_AS NULL ,<br>[Note] [nvarchar] (2000) COLLATE Chinese_PRC_CI_AS NULL<br>) ON [PRIMARY]<br>GO  </p>\n<p>插入数据：(2万条，用更多的数据测试会明显一些)<br>SET IDENTITY_INSERT TestTable ON  </p>\n<p>declare @i int<br>set @i&#x3D;1<br>while @i&lt;&#x3D;20000<br>begin<br>insert into TestTable([id], FirstName, LastName, Country,Note) values(@i, ‘’FirstName_XXX’’,’’LastName_XXX’’,’’Country_XXX’’,’’Note_XXX’’)<br>set @i&#x3D;@i+1<br>end  </p>\n<p>SET IDENTITY_INSERT TestTable OFF  </p>\n<p>-————————————  </p>\n<p>分页方案一：(利用Not In和SELECT TOP分页)<br>语句形式：<br>SELECT TOP 10 *<br>FROM TestTable<br>WHERE (ID NOT IN<br>(SELECT TOP 20 id<br>FROM TestTable<br>ORDER BY id))<br>ORDER BY ID  </p>\n<p>SELECT TOP 页大小 *<br>FROM TestTable<br>WHERE (ID NOT IN<br>(SELECT TOP 页大小*页数 id<br>FROM 表<br>ORDER BY id))<br>ORDER BY ID  </p>\n<p>-————————————  </p>\n<p>分页方案二：(利用ID大于多少和SELECT TOP分页）<br>语句形式：<br>SELECT TOP 10 *<br>FROM TestTable<br>WHERE (ID &gt;<br>(SELECT MAX(id)<br>FROM (SELECT TOP 20 id<br>FROM TestTable<br>ORDER BY id) AS T))<br>ORDER BY ID  </p>\n<p>SELECT TOP 页大小 *<br>FROM TestTable<br>WHERE (ID &gt;<br>(SELECT MAX(id)<br>FROM (SELECT TOP 页大小*页数 id<br>FROM 表<br>ORDER BY id) AS T))<br>ORDER BY ID  </p>\n<p>-————————————  </p>\n<p>分页方案三：(利用SQL的游标存储过程分页)<br>create procedure XiaoZhengGe<br>@sqlstr nvarchar(4000), –查询字符串<br>@currentpage int, –第N页<br>@pagesize int –每页行数<br>as<br>set nocount on<br>declare @P1 int, –P1是游标的id<br>@rowcount int<br>exec sp_cursoropen @P1 output,@sqlstr,@scrollopt&#x3D;1,@ccopt&#x3D;1,@rowcount&#x3D;@rowcount output<br>select ceiling(1.0*@rowcount&#x2F;@pagesize) as 总页数–,@rowcount as 总行数,@currentpage as 当前页<br>set @currentpage&#x3D;(@currentpage-1)*@pagesize+1<br>exec sp_cursorfetch @P1,16,@currentpage,@pagesize<br>exec sp_cursorclose @P1<br>set nocount off  </p>\n<p>其它的方案：如果没有主键，可以用临时表，也可以用方案三做，但是效率会低。<br>建议优化的时候，加上主键和索引，查询效率会提高。  </p>\n<p>通过SQL 查询分析器，显示比较：我的结论是:<br>分页方案二：(利用ID大于多少和SELECT TOP分页）效率最高，需要拼接SQL语句<br>分页方案一：(利用Not In和SELECT TOP分页) 效率次之，需要拼接SQL语句<br>分页方案三：(利用SQL的游标存储过程分页) 效率最差，但是最为通用  </p>\n<p>在实际情况中，要具体分析。  </p>\n<p>源自：<a href=\"http://dev.csdn.net/author/jonas20/index.html\">jonas</a> (<a href=\"http://blog.csdn.net/jonas20/\" title=\"点击进入作者个人网站\">个人网站</a>)</p>\n","more":"<p>SQL Server 存储过程的经典分页 关键字：分页,存储过程 　 建立表： CREATE TABLE [TestTable] ( [ID] [int] IDENTITY (1, 1) NOT NULL , [FirstName] [nvarchar] (100) COLLATE Chinese_PRC_CI_AS NULL , [LastName] [nvarchar] (10…</p>\n<!-- more -->\n<p>SQL Server 存储过程的经典分页  </p>\n<p>关键字：<strong>分页,存储过程</strong></p>\n<p>　</p>\n<p>建立表：  </p>\n<p>CREATE TABLE [TestTable] (<br>[ID] [int] IDENTITY (1, 1) NOT NULL ,<br>[FirstName] [nvarchar] (100) COLLATE Chinese_PRC_CI_AS NULL ,<br>[LastName] [nvarchar] (100) COLLATE Chinese_PRC_CI_AS NULL ,<br>[Country] [nvarchar] (50) COLLATE Chinese_PRC_CI_AS NULL ,<br>[Note] [nvarchar] (2000) COLLATE Chinese_PRC_CI_AS NULL<br>) ON [PRIMARY]<br>GO  </p>\n<p>插入数据：(2万条，用更多的数据测试会明显一些)<br>SET IDENTITY_INSERT TestTable ON  </p>\n<p>declare @i int<br>set @i&#x3D;1<br>while @i&lt;&#x3D;20000<br>begin<br>insert into TestTable([id], FirstName, LastName, Country,Note) values(@i, ‘’FirstName_XXX’’,’’LastName_XXX’’,’’Country_XXX’’,’’Note_XXX’’)<br>set @i&#x3D;@i+1<br>end  </p>\n<p>SET IDENTITY_INSERT TestTable OFF  </p>\n<p>-————————————  </p>\n<p>分页方案一：(利用Not In和SELECT TOP分页)<br>语句形式：<br>SELECT TOP 10 *<br>FROM TestTable<br>WHERE (ID NOT IN<br>(SELECT TOP 20 id<br>FROM TestTable<br>ORDER BY id))<br>ORDER BY ID  </p>\n<p>SELECT TOP 页大小 *<br>FROM TestTable<br>WHERE (ID NOT IN<br>(SELECT TOP 页大小*页数 id<br>FROM 表<br>ORDER BY id))<br>ORDER BY ID  </p>\n<p>-————————————  </p>\n<p>分页方案二：(利用ID大于多少和SELECT TOP分页）<br>语句形式：<br>SELECT TOP 10 *<br>FROM TestTable<br>WHERE (ID &gt;<br>(SELECT MAX(id)<br>FROM (SELECT TOP 20 id<br>FROM TestTable<br>ORDER BY id) AS T))<br>ORDER BY ID  </p>\n<p>SELECT TOP 页大小 *<br>FROM TestTable<br>WHERE (ID &gt;<br>(SELECT MAX(id)<br>FROM (SELECT TOP 页大小*页数 id<br>FROM 表<br>ORDER BY id) AS T))<br>ORDER BY ID  </p>\n<p>-————————————  </p>\n<p>分页方案三：(利用SQL的游标存储过程分页)<br>create procedure XiaoZhengGe<br>@sqlstr nvarchar(4000), –查询字符串<br>@currentpage int, –第N页<br>@pagesize int –每页行数<br>as<br>set nocount on<br>declare @P1 int, –P1是游标的id<br>@rowcount int<br>exec sp_cursoropen @P1 output,@sqlstr,@scrollopt&#x3D;1,@ccopt&#x3D;1,@rowcount&#x3D;@rowcount output<br>select ceiling(1.0*@rowcount&#x2F;@pagesize) as 总页数–,@rowcount as 总行数,@currentpage as 当前页<br>set @currentpage&#x3D;(@currentpage-1)*@pagesize+1<br>exec sp_cursorfetch @P1,16,@currentpage,@pagesize<br>exec sp_cursorclose @P1<br>set nocount off  </p>\n<p>其它的方案：如果没有主键，可以用临时表，也可以用方案三做，但是效率会低。<br>建议优化的时候，加上主键和索引，查询效率会提高。  </p>\n<p>通过SQL 查询分析器，显示比较：我的结论是:<br>分页方案二：(利用ID大于多少和SELECT TOP分页）效率最高，需要拼接SQL语句<br>分页方案一：(利用Not In和SELECT TOP分页) 效率次之，需要拼接SQL语句<br>分页方案三：(利用SQL的游标存储过程分页) 效率最差，但是最为通用  </p>\n<p>在实际情况中，要具体分析。  </p>\n<p>源自：<a href=\"http://dev.csdn.net/author/jonas20/index.html\">jonas</a> (<a href=\"http://blog.csdn.net/jonas20/\" title=\"点击进入作者个人网站\">个人网站</a>)</p>\n","categories":[],"tags":[]}
{"title":"监视所有 HTTP 请求和响应的工具 Fiddler工具介绍 (转载)-CarlZeng","slug":"监视所有-HTTP-请求和响应的工具-Fiddler工具介绍-转载-CarlZeng","date":"2008-12-31T03:51:00.000Z","updated":"2023-12-13T06:45:54.518Z","comments":true,"path":"api/articles/监视所有-HTTP-请求和响应的工具-Fiddler工具介绍-转载-CarlZeng.json","excerpt":"Fildder 是一个用来监视所有 HTTP 请求和响应的工具","covers":["http://images.cnblogs.com/cnblogs_com/framework/ie_introfiddler_fig01.gif","http://images.cnblogs.com/cnblogs_com/framework/ie_introfiddler_fig02.gif","http://images.cnblogs.com/cnblogs_com/framework/ie_introfiddler_fig03.gif","http://images.cnblogs.com/cnblogs_com/framework/ie_introfiddler_fig04.gif","http://images.cnblogs.com/cnblogs_com/framework/ie_introfiddler_fig05.gif","http://images.cnblogs.com/cnblogs_com/framework/ie_introfiddler_fig06.gif"],"content":"<p>Fildder 是一个用来监视所有 HTTP 请求和响应的工具</p>\n<span id=\"more\"></span>\n<p>Fildder 是一个用来监视所有 HTTP 请求和响应的工具，这对于调试 WEB 应用程序来说是一个很有用的工具，此工具的官方网站是：<a href=\"http://www.fiddlertool.com/\">http://www.fiddlertool.com</a>  </p>\n<p>下面是两篇对此工具进行介绍的中文文档：</p>\n<p>Fiddler工具介绍一<br>(原文地址：<a href=\"http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dnwebgen/html/IE_IntroFiddler.asp\">http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dnwebgen/html/IE_IntroFiddler.asp</a>)  </p>\n<p>这个工具我已经使用比较长时间了，对我的帮助也挺大，今天我翻译的微软的文章，让更多的朋友都来了解这个不错的工具，也是我第一次翻译文章，不恰当之处请大家大家多多指正。<br>介绍：</p>\n<p>你是不是曾经疑惑过你的web程序和IE是如何交互的？你是不是遇到过一些奇怪的而你又无法解决的性能瓶颈？你是不是对那些发送给服务器端的cookie 和那些你下载下来的被标记为可缓存的内容感到好奇？</p>\n<p>Fiddler官方网站及下载地址：<a href=\"http://www.fiddlertool.com/Fiddler/dev/\">http://www.fiddlertool.com/Fiddler/dev/</a></p>\n<p>微软的Fiddler能够帮助你回答以上的问题，不但如此，它还是一个http调试代理，它能够记录所有的你电脑和互联网之间的http通讯，Fiddler 可以也可以让你检查所有的http通讯，设置断点，以及Fiddle 所有的”进出”的数据（指cookie,html,js,css等文件，这些都可以让你胡乱修改的意思）。 Fiddler 要比其他的网络调试器要更加简单，因为它仅仅暴露http通讯还有提供一个用户友好的格式。</p>\n<p>Fiddler 包含一个简单却功能强大的基于JScript .NET 事件脚本子系统，他非常灵活性非常棒，可以支持众多的http调试任务。Fiddler 是用C#写出来的。</p>\n<p>。。。。。接下来是一大段废话，关于如何安装的，只要一路next，就可以了。这段话我就跳过，直接切入正题了。</p>\n<p>Running Fiddler</p>\n<p>当你启动了Fiddler，程序将会把自己作为一个微软互联网服务的系统代理中去。你可以通过检查代理设置对话框来验证Fiddler是被正确地截取了web请求。操作是这样的：点击IE设置，工具，局域网设置，最后点击高级。<br><img data-src=\"http://images.cnblogs.com/cnblogs_com/framework/ie_introfiddler_fig01.gif\"></p>\n<p>作为系统代理，所有的来自微软互联网服务（WinInet）的http请求再到达目标Web服务器的之前都会经过Fiddle，同样的，所有的Http响应都会在返回客户端之前流经Fiddler。这样，就能明白Fiddler很多作用了吧！<br><img data-src=\"http://images.cnblogs.com/cnblogs_com/framework/ie_introfiddler_fig02.gif\"></p>\n<p>当你关闭Fiddler的时候，它就会自动从系统注册表中移出，换句话说，当你关闭了Fiddler后，不会占着茅坑不拉屎。</p>\n<p>下面，是一个Fillder的用户界面，大家可以参考参考其功能。  </p>\n<p><img data-src=\"http://images.cnblogs.com/cnblogs_com/framework/ie_introfiddler_fig03.gif\"></p>\n<h2 id=\"用Fiddler来做性能测试\"><a href=\"#用Fiddler来做性能测试\" class=\"headerlink\" title=\"用Fiddler来做性能测试\"></a>用Fiddler来做性能测试</h2><h2 id=\"HTTP统计视图\"><a href=\"#HTTP统计视图\" class=\"headerlink\" title=\"HTTP统计视图\"></a>HTTP统计视图</h2><p>通过显示所有的Http通讯，Fiddler可以轻松的演示哪些用来生成一个页面，通过统计页面（就是Fiddler左边的那个大框）用户可以很轻松的使用多选，来得到一个WEB页面的”总重量”（页面文件以及相关js,css等）你也可以很轻松得看到你请求的某个页面，总共请求了多少次，以及多少字节被转化了。  </p>\n<p><img data-src=\"http://images.cnblogs.com/cnblogs_com/framework/ie_introfiddler_fig04.gif\"></p>\n<p>另外，通过暴露HTTP头，用户可以看见哪些页面被允许在客户端或者是代理端进行缓存。如果要是一个响应没有包含Cache-Control 头，那么他就不会被缓存在客户端。  </p>\n<p><img data-src=\"http://images.cnblogs.com/cnblogs_com/framework/ie_introfiddler_fig05.gif\">  </p>\n<p>用Fiddler来调试</p>\n<p>Fiddler支持断点调试概念，当你在软件的菜单-rules-automatic breakpoints选项选择beforerequest,或者当这些请求或响应属性能够跟目标的标准相匹配，Fiddler就能够暂停Http通讯，情切允许修改请求和响应。这种功能对于安全测试是非常有用的，当然也可以用来做一般的功能测试，因为所有的代码路径都可以用来演习。</p>\n<p><img data-src=\"http://images.cnblogs.com/cnblogs_com/framework/ie_introfiddler_fig06.gif\"></p>\n<h2 id=\"Session检查\"><a href=\"#Session检查\" class=\"headerlink\" title=\"Session检查\"></a>Session检查</h2><p>用户可以在BuilderPage项种来以手工的方式来创建一个HTTP请求（即在 Fiddler右侧的tab的第三个，RequestBUILDER），或者可以使用拖拽操作从Session列表中来移动一个已经存在的请求到 builder page 来再次执行这个请求。。。</p>\n<h2 id=\"Fiddler-扩展\"><a href=\"#Fiddler-扩展\" class=\"headerlink\" title=\"Fiddler 扩展\"></a>Fiddler 扩展</h2><p>Fiddler可以使用 .net framework来对它进行扩展。有2种为Fiddler扩展准备的基本机制：</p>\n<p>自定义规则，和规则检查。</p>\n<h2 id=\"使用脚本化的规则来扩展Fiddler\"><a href=\"#使用脚本化的规则来扩展Fiddler\" class=\"headerlink\" title=\"使用脚本化的规则来扩展Fiddler\"></a>使用脚本化的规则来扩展Fiddler</h2><p>Fiddler支持JScript .NET引擎，它可以允许用户自动地修改Http请求和响应。这个引擎能够在可视化界面修改在FiddlerUI中的Session，可以从列表中提取你感兴趣的错误，也可以移除你不感兴趣的Session。</p>\n<p>以下的示例代码演示当cookie被加载的时候把界面变成紫色。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">function</span> <span class=\"title function_\">OnBeforeRequest</span>(<span class=\"params\">oSession:Fiddler.Session</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">if</span> (oSession.<span class=\"property\">oRequest</span>.<span class=\"property\">headers</span>.<span class=\"title class_\">Exists</span>(<span class=\"string\">&quot;Cookie&quot;</span>))&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">      oSession\\[<span class=\"string\">&quot;ui-color&quot;</span>\\] = <span class=\"string\">&quot;purple&quot;</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">      oSession\\[<span class=\"string\">&quot;ui-bold&quot;</span>\\] = <span class=\"string\">&quot;cookie&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过加入Inspectors来扩展Fiddler</p>\n<p>用户可以加入一个Inspector插件对象，来使用.net下的任何语言来编写Fiddler扩展。RequestInspectors 和 ResponseInspectors提供一个格式规范的，或者是被指定的（用户自定义）Http请求和响应视图。</p>\n<p>默认安装中，Fiddler加入了一下的Inspectors：</p>\n<p>Request Inspectors</p>\n<p>[RW] Headers-Shows request headers and status.</p>\n<p>[RW] TextView-Shows the request body in a text box. （原始的请求body视图）</p>\n<p>[RW] HexView-Shows the request body in a hexadecimal view. （body的16进制视图）</p>\n<p>[RO] XML-Shows the request body as an XML DOM in a tree view.（以XML方式展示请求）</p>\n<p>Response Inspectors</p>\n<p>[RW] Transformer-Removes GZip, DEFLATE, and CHUNKED encodings for easier debugging.</p>\n<p>[RW] Headers-Shows response headers and status.</p>\n<p>[RW] TextView-Shows the response body in a text box.</p>\n<p>[RW] HexView-Shows the response body in a hexadecimal view. （16进制视图）</p>\n<p>[RO] ImageView-Shows the response body as an Image. Supports all .NET image formats.</p>\n<p>[RO] XML-Shows the response body as an XML DOM in a tree view.</p>\n<p>[RO] Privacy-Explains the P3P statement in the response headers, if present.（如果在响应头中有关于隐私策略的说明就展示出来）</p>\n<p>Fiddler的高级篇。</p>\n<p><a href=\"http://www.cnblogs.com/FrameWork/archive/2006/10/16/530827.html\">HTTP调试工具：Fiddler 介绍二</a></p>\n<p>学习如何通过Fiddler建立一个速度更快的网站。在这篇文章中，我们将使用Fiddler去探究HTTP的性能，缓存，以及压缩。</p>\n<p>如果你要是没有安装和配置过Fiddler， 请从文章的第一篇开始。</p>\n<h2 id=\"HTTP性能总览\"><a href=\"#HTTP性能总览\" class=\"headerlink\" title=\"HTTP性能总览\"></a>HTTP性能总览</h2><p>毫无疑问用户都喜欢访问速度快的网站。用户是非常的不耐烦，除非你的网站是没有竞争对手，换句话就是处于垄断地位的。如果你的访问者来自世界各地，那你就必须要保证你的网站在执行效率方面要非常好，甚至要更加标准。作为一个国际化的网络连接点，通常要受到来自两个方面的压力：高访问量以及低带宽。</p>\n<p>在第一次至关重要的访问中，用户必须要下载每一个内容片断，来生成页面，包括JS，CSS，Images，HTML，如果你的页面太难加载（包括IIS接到请求执行并返回给客户端HTML），访问者也许就会离开你的页面！</p>\n<p>通过暴露所有的HTTP通讯，Fiddler很容易得向你展示哪些文件经常被用于生成一个页面，</p>\n<p>Shift+click 可以在Fiddler左边框的会话列表中多选会话，来计算那些被选会话的”页面总重量”。那些被转换成字节的数量。</p>\n<p>如果你想让你的客户在第一次访问的时候就留下深刻的印象 ，那么最好的，也是唯一的途径就是返回给客户更少的文件。</p>\n<p>1 使用更少的图画</p>\n<p>2 将所有的CSS浓缩到一个CSS文件中</p>\n<p>3 将所有的脚本浓缩到一个JS文件中</p>\n<p>4 简化你的页面时间</p>\n<p>5 使用HTTP压缩</p>\n<p>如果要是你已经对用户的第一次来访的性能进行了优化，那么你可以通过Http 缓存的优势来使得你的网站访问速度更快！</p>\n<h2 id=\"HTTP-缓存介绍\"><a href=\"#HTTP-缓存介绍\" class=\"headerlink\" title=\"HTTP 缓存介绍\"></a>HTTP 缓存介绍</h2><p>2种方式来提升你的web 应用程序的速度：</p>\n<p>减少请求和响应的往返次数</p>\n<p>减少请求和响应的往返字节大小。</p>\n<p>HTTP缓存是最好的减少客户端服务器端往返次数的办法。缓存提供了提供一种机制来保证客户端或者代理能够存储一些东西，而这些东西将会在稍后的HTTP 响应中用到的。（即第一次请求了，到了客户端，缓存起来，下次如果页面还要这个JS文件或者CSS文件啥的，就不要到服务器端去取下来了，但是还是要去服务器上去访问一次，因为请求要对比ETAG值，关于这个值，我将会在下次翻译中介绍其作用）这样，就不用让文件再次跨越整个网络了。</p>\n<h3 id=\"缓存相关的请求头\"><a href=\"#缓存相关的请求头\" class=\"headerlink\" title=\"缓存相关的请求头\"></a>缓存相关的请求头</h3><p>为了提高性能，微软的IE和其他的web客户端总是想尽办法来维持从远程服务器上下载下来的本地的缓存。</p>\n<p>当客户端需要一个资源（html,css.js…），他们有3种可能的动作：</p>\n<p>1 发送一个一般的HTTP请求到远程服务器端，请求这个资源。</p>\n<p>2 发送一个有条件的HTTP请求到服务器，条件就是如果它不同于本地的缓存版本。</p>\n<p>3 如果缓存的拷贝可用，就使用本地的缓存资源。</p>\n<p>当发送一个请求，客户也许会使用如下的几个HEADER</p>\n<p>Table 1. Client Cache Headers</p>\n<p>Pragma: no-cache</p>\n<p>The client is unwilling to accept any cached responses from caches along the route and the origin server must be contacted for a fresh copy of the resource.</p>\n<p>If-Modified-Since: datetime</p>\n<p>The server should return the requested resource only if the resource has been modified since the date-time provided by the client.</p>\n<p>If-None-Match: etagvalue</p>\n<p>The server should return the requested resource if the ETAG of the resource is different than the value provided by the client. An <a href=\"http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.19\">ETAG</a> is a unique identifier representing a particular version of a file.</p>\n<p>1 Pragma：no-cache 表明客户端不愿意接受缓存请求，它需要的是最即时的资源。</p>\n<p>2 If-Modified-Since: datetime 表明如果这个资源自从上次被客户端请求，就已经修改了，那么服务器就会返回给客户端最新的。</p>\n<p>3 If-None-Match: etagvalue 如果客户端资源的ETAG值跟服务器端不一致了，那么服务器端返回最新的资源。ETAG就是一个唯一的ID，用来表示一个文件的一个特定的版本。</p>\n<p>如果要是这些有条件的请求，也就是含有If-Modified-Since 或者 If-None-MatchHeader头的请求，服务器将会以HTTP&#x2F;304 Not Modified 来作为响应，那么客户端就知道可以使用客户端的缓存了。否则，服务器将会返回一个新的响应并且客户端就会抛弃过期的缓存资源。</p>\n<p>你可以观察2个连贯的请求，来请求同一个图片，你会在Fiddler中发现：在第一个本地缓存版本中，服务器返回一个含有ETAG的文件，和一个含有最后修改日期的文件，在这个第一次的请求会话中，一个本地的缓存版本已经可以使用了。这样一来，一个有条件的请求就被创建出来。然后你再次请求这个图片的时候，他就就会响应一个本地缓存的文件，当然前提是第一次缓存的图片的ETAG值或者If- Modified-Since 值跟服务器上匹配的话，服务器就响应一个304给客户端。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Session #1</span><br><span class=\"line\"></span><br><span class=\"line\">GET /images/banner.jpg HTTP/1.1</span><br><span class=\"line\"></span><br><span class=\"line\">Host: www.bayden.com</span><br><span class=\"line\"></span><br><span class=\"line\">HTTP/1.1 200 OK</span><br><span class=\"line\"></span><br><span class=\"line\">Date: Tue, 08 Mar 2006 00:32:46 GMT</span><br><span class=\"line\"></span><br><span class=\"line\">Content-Length: 6171</span><br><span class=\"line\"></span><br><span class=\"line\">Content-Type: image/jpeg</span><br><span class=\"line\"></span><br><span class=\"line\">ETag: &quot;40c7f76e8d30c31:2fe20&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">Last-Modified: Thu, 12 Jun 2003 02:50:50 GMT</span><br><span class=\"line\"></span><br><span class=\"line\">Session #2</span><br><span class=\"line\"></span><br><span class=\"line\">GET /images/banner.jpg HTTP/1.1</span><br><span class=\"line\"></span><br><span class=\"line\">If-Modified-Since: Thu, 12 Jun 2003 02:50:50 GMT</span><br><span class=\"line\"></span><br><span class=\"line\">If-None-Match: &quot;40c7f76e8d30c31:2fe20&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">Host: www.bayden.com</span><br><span class=\"line\"></span><br><span class=\"line\">HTTP/1.1 304 Not Modified</span><br></pre></td></tr></table></figure>\n\n\n\n<p>因为一个HTTP304响应仅仅包含头，没有body,所有它在穿越互联网的时候要比携带了资源的快很多，尽管如此，HTTP&#x2F;304响应需要一个服务器的往返，但是通过细心的设置响应头，web程序员可以消除这种因素，甚至是有条件的请求。</p>\n<h3 id=\"缓存相关响应头\"><a href=\"#缓存相关响应头\" class=\"headerlink\" title=\"缓存相关响应头\"></a>缓存相关响应头</h3><p>通常缓存机制是由响应头来控制的。HTTP规范描述了Header控制缓存，The optional Cache-Control，Expires（过期）。</p>\n<p>Expires头包含一个绝对的日期，当超过此日期，它将不会被考虑更新了。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Table 2. Common Cache-Control Headers</span><br><span class=\"line\"></span><br><span class=\"line\">Value</span><br><span class=\"line\"></span><br><span class=\"line\">Meaning</span><br><span class=\"line\"></span><br><span class=\"line\">public</span><br><span class=\"line\"></span><br><span class=\"line\">The response may be stored in any cache, including caches shared among many users.</span><br><span class=\"line\"></span><br><span class=\"line\">private</span><br><span class=\"line\"></span><br><span class=\"line\">The response may only be stored in a private cache used by a single user.</span><br><span class=\"line\"></span><br><span class=\"line\">no-cache</span><br><span class=\"line\"></span><br><span class=\"line\">The response should not be reused to satisfy future requests.</span><br><span class=\"line\"></span><br><span class=\"line\">no-store</span><br><span class=\"line\"></span><br><span class=\"line\">The response should not be reused to satisfy future requests, and should not be written to disk. This is primarily used as a security measure for sensitive responses.</span><br><span class=\"line\"></span><br><span class=\"line\">max-age=#seconds</span><br><span class=\"line\"></span><br><span class=\"line\">The response may be reused to satisfy future requests within a certain number of seconds.</span><br><span class=\"line\"></span><br><span class=\"line\">must-revalidate</span><br><span class=\"line\"></span><br><span class=\"line\">The response may be reused to satisfy future requests, but the origin server should first be contacted to verify that the response is still fresh.</span><br><span class=\"line\"></span><br><span class=\"line\">Cache-Control头的参数设置：</span><br><span class=\"line\"></span><br><span class=\"line\">Public 响应会被缓存，并且在多用户间共享。</span><br><span class=\"line\"></span><br><span class=\"line\">Private 响应只能够作为私有的缓存，不能再用户间共享。</span><br><span class=\"line\"></span><br><span class=\"line\">No-cache 响应不会被缓存</span><br><span class=\"line\"></span><br><span class=\"line\">No-store 响应不会被缓存，并且不会被写入到客户端的磁盘里，这也是基于安全考虑的某些敏感的响应才会使用这个。</span><br><span class=\"line\"></span><br><span class=\"line\">Max-age=#seconds 响应将会某个指定的秒数内缓存，一旦时间过了，就不会被缓存。</span><br><span class=\"line\"></span><br><span class=\"line\">Must-revalidate 响应会被重用来满足接下来的请求，但是它必须到服务器端去验证它是不是仍然是最新的。</span><br></pre></td></tr></table></figure>\n\n<p>注意：</p>\n<p>如果你要想在iis中配置缓存，请参阅温软的知识技术文章：</p>\n<p>· <a href=\"http://support.microsoft.com/default.aspx?scid=kb;en-us;247404\">How to Modify the Cache-Control HTTP Header When You Use IIS</a>.</p>\n<p>你可以学习更多关于在asp.net中使用缓存的知识文章：</p>\n<p>· <a href=\"http://support.microsoft.com/default.aspx?scid=kb;en-us;323290\">How To Cache in ASP.NET by Using Visual C# .NET</a>.</p>\n<p>如果你发现你经常在你的网站上更新文件，但是并没有更改文件名字，那你就必须要非常小心地设置你的缓存生存时间。例如：如果你要一个thisyear.gif图片文件显示当前的年份在网站上，你需要保证这个缓存过期时间不能超过一天，否则一个用户在12月31号访问你的网站的时候，在1月1号就不能显示正确的日期。</p>\n<p>由于某些原因，服务器可能会设置：Progma：no-cache 头，Cache-control:no-cache</p>\n<p>Header中的参数：Vary 是一个缓存信号，Vary：User-Agent表示缓存当前的响应，但是仅限于当发送同样的User-Agent 头的时候。指令 Vary：* 就相当于Cache-Control：no-Cache。</p>\n<p>Vary就相当于asp.net中的缓存的参数一样，意思是根据什么来缓存，如果要是知道asp.net的缓存的使用方法，就很容易明白这个参数的意思。</p>\n<p>使用HTTP会话列表，Fiddler用户可以看到在页面里包含的ＨＴＴＰ缓存头。</p>\n<h3 id=\"Fiddler会话列表\"><a href=\"#Fiddler会话列表\" class=\"headerlink\" title=\"Fiddler会话列表\"></a>Fiddler会话列表</h3><p>如果响应不包含Ｅｘｐｉｒｅｓ或者Ｃａｃｈｅ－Ｃｏｎｔｒｏｌ，那么客户端就会被迫作为一个有条件的请求，来保证所有的资源都是最新的。</p>\n<p>有条件的请求和ＷｉｎＩｎｅｔＣａｃｈｅ</p>\n<p>ＩＥ通过Ｍｉｃｒｏｓｏｆｔ　ｗｉｎｄｏｗｓ　Ｉｎｔｅｒｎｅｔ　Ｓｅｒｖｉｃｅｓ来最大程度的利用缓存服务。ＷｉｎＩｎｅｔ允许用户配置缓存的大小和行为，设置缓存进行如下操作：</p>\n<p>１　打开ＩＥ，</p>\n<p>２　工具选项，选择Ｉｎtｅｒｎｅｔ选项，在一般子选项中，临时文件夹内，点击设置</p>\n<p>下图就是选村的四种设置：</p>\n<p>标记性能问题：</p>\n<p>你可以使用Ｆｉｄｄｌｅｒ的自定义规则来标记某些你需要的，比如如果某个响应大于２５ＫＢ，你可以把当前的Ｓｅｓｓｉｏｎ标记为红色，更加醒目。以下代码都是在OnBeforeResponse事件中：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Flag files over 25KB</span><br><span class=\"line\"></span><br><span class=\"line\">   if (oSession.responseBodyBytes.length &gt; 25000)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">      oSession\\[&quot;ui-color&quot;\\] = &quot;red&quot;;</span><br><span class=\"line\">    </span><br><span class=\"line\">      oSession\\[&quot;ui-bold&quot;\\] = &quot;true&quot;;</span><br><span class=\"line\">    </span><br><span class=\"line\">      oSession\\[&quot;ui-customcolumn&quot;\\] = &quot;Large file&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">同样，你也可以标记响应并不指示缓存信息。</span><br><span class=\"line\"></span><br><span class=\"line\">   // Mark files which do not have caching information</span><br><span class=\"line\"></span><br><span class=\"line\">if (!oSession.oResponse.headers.Exists(&quot;Expires&quot;) &amp;&amp;</span><br><span class=\"line\"></span><br><span class=\"line\">!oSession.oResponse.headers.Exists(&quot;Cache-Control&quot;))&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">oSession\\[&quot;ui-color&quot;\\] = &quot;purple&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">      oSession\\[&quot;ui-bold&quot;\\] = &quot;true&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"介绍HTTP压缩\"><a href=\"#介绍HTTP压缩\" class=\"headerlink\" title=\"介绍HTTP压缩\"></a>介绍HTTP压缩</h2><p>所有的目前流行的ＷＥＢ服务器和浏览器都提供ＨＴＴＰ压缩支持。ＨＴＴＰ压缩可以非常显著地降低客户端和服务器端的通讯量。节省超过５０％的ＨＴＭＬ，ＸＭＬ，ＣＳＳ，ＪＳ等文件。一个浏览器发送一个信号给服务器，他可以介绍ＨＴＴＰ压缩过的内容，并且会把客户端所支持的压缩类型放在请求的Ｈｅａｄｅｒ中，例如：考虑如下的请求：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET / HTTP/1.1</span><br><span class=\"line\"></span><br><span class=\"line\">Accept: \\*/\\*</span><br><span class=\"line\"></span><br><span class=\"line\">Accept-Language: en-us</span><br><span class=\"line\"></span><br><span class=\"line\">Accept-Encoding: gzip, deflate</span><br><span class=\"line\"></span><br><span class=\"line\">User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 1.1.4322)</span><br><span class=\"line\"></span><br><span class=\"line\">Host: search.msn.com</span><br><span class=\"line\"></span><br><span class=\"line\">这个　Ａｃｃｅｐｔ－Ｅｎｃｏｄｉｎｇ　头表明ＩＥ将愿意接受ＧＺＩＰ格式的和ＤＥＦＬＡＴＥ格式的压缩响应。</span><br><span class=\"line\"></span><br><span class=\"line\">相应的响应如下：</span><br><span class=\"line\"></span><br><span class=\"line\">HTTP/1.1 200 OK</span><br><span class=\"line\"></span><br><span class=\"line\">Content-Type: text/html; charset=utf-8</span><br><span class=\"line\"></span><br><span class=\"line\">Server: Microsoft-IIS/6.0 --Microsoft-HTTPAPI/1.0</span><br><span class=\"line\"></span><br><span class=\"line\">X-Powered-By: ASP.NET</span><br><span class=\"line\"></span><br><span class=\"line\">Vary: Accept-Encoding</span><br><span class=\"line\"></span><br><span class=\"line\">Content-Encoding: gzip</span><br><span class=\"line\"></span><br><span class=\"line\">Date: Tue, 15 Feb 2006 09:14:36 GMT</span><br><span class=\"line\"></span><br><span class=\"line\">Content-Length: 1277</span><br><span class=\"line\"></span><br><span class=\"line\">Connection: close</span><br><span class=\"line\"></span><br><span class=\"line\">Cache-Control: private, max-age=3600</span><br></pre></td></tr></table></figure>\n\n<p>你可以使用Ｆｉｄｄｌｅｒ来解压缩这些数据。实验表明，使用ＨＴＴＰ压缩能大量减少数据往返，一个普通的ＣＳＳ文件甚至能减少８０％！当然压缩是以牺牲ＣＰＵ性能为代价的。特别是压缩动态文件，但是一般的权宜之策是压缩例如ＪＳ，ＣＳＳ等静态文件，因为他们在第一次压缩后，就会被存储在服务器上，如果要压缩ａｓｐ．ｎｅｔ动态文件，一定要有个权衡才行</p>\n<p>如果您现在还是不满足您的程序优化，那么你还可以参看这篇文章，</p>\n<p><a href=\"http://msdn.microsoft.com/msdnmag/issues/05/01/ASPNETPerformance/default.aspx\">Ten Tips for Writing High-Performance Web Applications</a></p>\n","more":"<p>Fildder 是一个用来监视所有 HTTP 请求和响应的工具，这对于调试 WEB 应用程序来说是一个很有用的工具，此工具的官方网站是：<a href=\"http://www.fiddlertool.com/\">http://www.fiddlertool.com</a>  </p>\n<p>下面是两篇对此工具进行介绍的中文文档：</p>\n<p>Fiddler工具介绍一<br>(原文地址：<a href=\"http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dnwebgen/html/IE_IntroFiddler.asp\">http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dnwebgen/html/IE_IntroFiddler.asp</a>)  </p>\n<p>这个工具我已经使用比较长时间了，对我的帮助也挺大，今天我翻译的微软的文章，让更多的朋友都来了解这个不错的工具，也是我第一次翻译文章，不恰当之处请大家大家多多指正。<br>介绍：</p>\n<p>你是不是曾经疑惑过你的web程序和IE是如何交互的？你是不是遇到过一些奇怪的而你又无法解决的性能瓶颈？你是不是对那些发送给服务器端的cookie 和那些你下载下来的被标记为可缓存的内容感到好奇？</p>\n<p>Fiddler官方网站及下载地址：<a href=\"http://www.fiddlertool.com/Fiddler/dev/\">http://www.fiddlertool.com/Fiddler/dev/</a></p>\n<p>微软的Fiddler能够帮助你回答以上的问题，不但如此，它还是一个http调试代理，它能够记录所有的你电脑和互联网之间的http通讯，Fiddler 可以也可以让你检查所有的http通讯，设置断点，以及Fiddle 所有的”进出”的数据（指cookie,html,js,css等文件，这些都可以让你胡乱修改的意思）。 Fiddler 要比其他的网络调试器要更加简单，因为它仅仅暴露http通讯还有提供一个用户友好的格式。</p>\n<p>Fiddler 包含一个简单却功能强大的基于JScript .NET 事件脚本子系统，他非常灵活性非常棒，可以支持众多的http调试任务。Fiddler 是用C#写出来的。</p>\n<p>。。。。。接下来是一大段废话，关于如何安装的，只要一路next，就可以了。这段话我就跳过，直接切入正题了。</p>\n<p>Running Fiddler</p>\n<p>当你启动了Fiddler，程序将会把自己作为一个微软互联网服务的系统代理中去。你可以通过检查代理设置对话框来验证Fiddler是被正确地截取了web请求。操作是这样的：点击IE设置，工具，局域网设置，最后点击高级。<br><img data-src=\"http://images.cnblogs.com/cnblogs_com/framework/ie_introfiddler_fig01.gif\"></p>\n<p>作为系统代理，所有的来自微软互联网服务（WinInet）的http请求再到达目标Web服务器的之前都会经过Fiddle，同样的，所有的Http响应都会在返回客户端之前流经Fiddler。这样，就能明白Fiddler很多作用了吧！<br><img data-src=\"http://images.cnblogs.com/cnblogs_com/framework/ie_introfiddler_fig02.gif\"></p>\n<p>当你关闭Fiddler的时候，它就会自动从系统注册表中移出，换句话说，当你关闭了Fiddler后，不会占着茅坑不拉屎。</p>\n<p>下面，是一个Fillder的用户界面，大家可以参考参考其功能。  </p>\n<p><img data-src=\"http://images.cnblogs.com/cnblogs_com/framework/ie_introfiddler_fig03.gif\"></p>\n<h2 id=\"用Fiddler来做性能测试\"><a href=\"#用Fiddler来做性能测试\" class=\"headerlink\" title=\"用Fiddler来做性能测试\"></a>用Fiddler来做性能测试</h2><h2 id=\"HTTP统计视图\"><a href=\"#HTTP统计视图\" class=\"headerlink\" title=\"HTTP统计视图\"></a>HTTP统计视图</h2><p>通过显示所有的Http通讯，Fiddler可以轻松的演示哪些用来生成一个页面，通过统计页面（就是Fiddler左边的那个大框）用户可以很轻松的使用多选，来得到一个WEB页面的”总重量”（页面文件以及相关js,css等）你也可以很轻松得看到你请求的某个页面，总共请求了多少次，以及多少字节被转化了。  </p>\n<p><img data-src=\"http://images.cnblogs.com/cnblogs_com/framework/ie_introfiddler_fig04.gif\"></p>\n<p>另外，通过暴露HTTP头，用户可以看见哪些页面被允许在客户端或者是代理端进行缓存。如果要是一个响应没有包含Cache-Control 头，那么他就不会被缓存在客户端。  </p>\n<p><img data-src=\"http://images.cnblogs.com/cnblogs_com/framework/ie_introfiddler_fig05.gif\">  </p>\n<p>用Fiddler来调试</p>\n<p>Fiddler支持断点调试概念，当你在软件的菜单-rules-automatic breakpoints选项选择beforerequest,或者当这些请求或响应属性能够跟目标的标准相匹配，Fiddler就能够暂停Http通讯，情切允许修改请求和响应。这种功能对于安全测试是非常有用的，当然也可以用来做一般的功能测试，因为所有的代码路径都可以用来演习。</p>\n<p><img data-src=\"http://images.cnblogs.com/cnblogs_com/framework/ie_introfiddler_fig06.gif\"></p>\n<h2 id=\"Session检查\"><a href=\"#Session检查\" class=\"headerlink\" title=\"Session检查\"></a>Session检查</h2><p>用户可以在BuilderPage项种来以手工的方式来创建一个HTTP请求（即在 Fiddler右侧的tab的第三个，RequestBUILDER），或者可以使用拖拽操作从Session列表中来移动一个已经存在的请求到 builder page 来再次执行这个请求。。。</p>\n<h2 id=\"Fiddler-扩展\"><a href=\"#Fiddler-扩展\" class=\"headerlink\" title=\"Fiddler 扩展\"></a>Fiddler 扩展</h2><p>Fiddler可以使用 .net framework来对它进行扩展。有2种为Fiddler扩展准备的基本机制：</p>\n<p>自定义规则，和规则检查。</p>\n<h2 id=\"使用脚本化的规则来扩展Fiddler\"><a href=\"#使用脚本化的规则来扩展Fiddler\" class=\"headerlink\" title=\"使用脚本化的规则来扩展Fiddler\"></a>使用脚本化的规则来扩展Fiddler</h2><p>Fiddler支持JScript .NET引擎，它可以允许用户自动地修改Http请求和响应。这个引擎能够在可视化界面修改在FiddlerUI中的Session，可以从列表中提取你感兴趣的错误，也可以移除你不感兴趣的Session。</p>\n<p>以下的示例代码演示当cookie被加载的时候把界面变成紫色。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">function</span> <span class=\"title function_\">OnBeforeRequest</span>(<span class=\"params\">oSession:Fiddler.Session</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">if</span> (oSession.<span class=\"property\">oRequest</span>.<span class=\"property\">headers</span>.<span class=\"title class_\">Exists</span>(<span class=\"string\">&quot;Cookie&quot;</span>))&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">      oSession\\[<span class=\"string\">&quot;ui-color&quot;</span>\\] = <span class=\"string\">&quot;purple&quot;</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">      oSession\\[<span class=\"string\">&quot;ui-bold&quot;</span>\\] = <span class=\"string\">&quot;cookie&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过加入Inspectors来扩展Fiddler</p>\n<p>用户可以加入一个Inspector插件对象，来使用.net下的任何语言来编写Fiddler扩展。RequestInspectors 和 ResponseInspectors提供一个格式规范的，或者是被指定的（用户自定义）Http请求和响应视图。</p>\n<p>默认安装中，Fiddler加入了一下的Inspectors：</p>\n<p>Request Inspectors</p>\n<p>[RW] Headers-Shows request headers and status.</p>\n<p>[RW] TextView-Shows the request body in a text box. （原始的请求body视图）</p>\n<p>[RW] HexView-Shows the request body in a hexadecimal view. （body的16进制视图）</p>\n<p>[RO] XML-Shows the request body as an XML DOM in a tree view.（以XML方式展示请求）</p>\n<p>Response Inspectors</p>\n<p>[RW] Transformer-Removes GZip, DEFLATE, and CHUNKED encodings for easier debugging.</p>\n<p>[RW] Headers-Shows response headers and status.</p>\n<p>[RW] TextView-Shows the response body in a text box.</p>\n<p>[RW] HexView-Shows the response body in a hexadecimal view. （16进制视图）</p>\n<p>[RO] ImageView-Shows the response body as an Image. Supports all .NET image formats.</p>\n<p>[RO] XML-Shows the response body as an XML DOM in a tree view.</p>\n<p>[RO] Privacy-Explains the P3P statement in the response headers, if present.（如果在响应头中有关于隐私策略的说明就展示出来）</p>\n<p>Fiddler的高级篇。</p>\n<p><a href=\"http://www.cnblogs.com/FrameWork/archive/2006/10/16/530827.html\">HTTP调试工具：Fiddler 介绍二</a></p>\n<p>学习如何通过Fiddler建立一个速度更快的网站。在这篇文章中，我们将使用Fiddler去探究HTTP的性能，缓存，以及压缩。</p>\n<p>如果你要是没有安装和配置过Fiddler， 请从文章的第一篇开始。</p>\n<h2 id=\"HTTP性能总览\"><a href=\"#HTTP性能总览\" class=\"headerlink\" title=\"HTTP性能总览\"></a>HTTP性能总览</h2><p>毫无疑问用户都喜欢访问速度快的网站。用户是非常的不耐烦，除非你的网站是没有竞争对手，换句话就是处于垄断地位的。如果你的访问者来自世界各地，那你就必须要保证你的网站在执行效率方面要非常好，甚至要更加标准。作为一个国际化的网络连接点，通常要受到来自两个方面的压力：高访问量以及低带宽。</p>\n<p>在第一次至关重要的访问中，用户必须要下载每一个内容片断，来生成页面，包括JS，CSS，Images，HTML，如果你的页面太难加载（包括IIS接到请求执行并返回给客户端HTML），访问者也许就会离开你的页面！</p>\n<p>通过暴露所有的HTTP通讯，Fiddler很容易得向你展示哪些文件经常被用于生成一个页面，</p>\n<p>Shift+click 可以在Fiddler左边框的会话列表中多选会话，来计算那些被选会话的”页面总重量”。那些被转换成字节的数量。</p>\n<p>如果你想让你的客户在第一次访问的时候就留下深刻的印象 ，那么最好的，也是唯一的途径就是返回给客户更少的文件。</p>\n<p>1 使用更少的图画</p>\n<p>2 将所有的CSS浓缩到一个CSS文件中</p>\n<p>3 将所有的脚本浓缩到一个JS文件中</p>\n<p>4 简化你的页面时间</p>\n<p>5 使用HTTP压缩</p>\n<p>如果要是你已经对用户的第一次来访的性能进行了优化，那么你可以通过Http 缓存的优势来使得你的网站访问速度更快！</p>\n<h2 id=\"HTTP-缓存介绍\"><a href=\"#HTTP-缓存介绍\" class=\"headerlink\" title=\"HTTP 缓存介绍\"></a>HTTP 缓存介绍</h2><p>2种方式来提升你的web 应用程序的速度：</p>\n<p>减少请求和响应的往返次数</p>\n<p>减少请求和响应的往返字节大小。</p>\n<p>HTTP缓存是最好的减少客户端服务器端往返次数的办法。缓存提供了提供一种机制来保证客户端或者代理能够存储一些东西，而这些东西将会在稍后的HTTP 响应中用到的。（即第一次请求了，到了客户端，缓存起来，下次如果页面还要这个JS文件或者CSS文件啥的，就不要到服务器端去取下来了，但是还是要去服务器上去访问一次，因为请求要对比ETAG值，关于这个值，我将会在下次翻译中介绍其作用）这样，就不用让文件再次跨越整个网络了。</p>\n<h3 id=\"缓存相关的请求头\"><a href=\"#缓存相关的请求头\" class=\"headerlink\" title=\"缓存相关的请求头\"></a>缓存相关的请求头</h3><p>为了提高性能，微软的IE和其他的web客户端总是想尽办法来维持从远程服务器上下载下来的本地的缓存。</p>\n<p>当客户端需要一个资源（html,css.js…），他们有3种可能的动作：</p>\n<p>1 发送一个一般的HTTP请求到远程服务器端，请求这个资源。</p>\n<p>2 发送一个有条件的HTTP请求到服务器，条件就是如果它不同于本地的缓存版本。</p>\n<p>3 如果缓存的拷贝可用，就使用本地的缓存资源。</p>\n<p>当发送一个请求，客户也许会使用如下的几个HEADER</p>\n<p>Table 1. Client Cache Headers</p>\n<p>Pragma: no-cache</p>\n<p>The client is unwilling to accept any cached responses from caches along the route and the origin server must be contacted for a fresh copy of the resource.</p>\n<p>If-Modified-Since: datetime</p>\n<p>The server should return the requested resource only if the resource has been modified since the date-time provided by the client.</p>\n<p>If-None-Match: etagvalue</p>\n<p>The server should return the requested resource if the ETAG of the resource is different than the value provided by the client. An <a href=\"http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.19\">ETAG</a> is a unique identifier representing a particular version of a file.</p>\n<p>1 Pragma：no-cache 表明客户端不愿意接受缓存请求，它需要的是最即时的资源。</p>\n<p>2 If-Modified-Since: datetime 表明如果这个资源自从上次被客户端请求，就已经修改了，那么服务器就会返回给客户端最新的。</p>\n<p>3 If-None-Match: etagvalue 如果客户端资源的ETAG值跟服务器端不一致了，那么服务器端返回最新的资源。ETAG就是一个唯一的ID，用来表示一个文件的一个特定的版本。</p>\n<p>如果要是这些有条件的请求，也就是含有If-Modified-Since 或者 If-None-MatchHeader头的请求，服务器将会以HTTP&#x2F;304 Not Modified 来作为响应，那么客户端就知道可以使用客户端的缓存了。否则，服务器将会返回一个新的响应并且客户端就会抛弃过期的缓存资源。</p>\n<p>你可以观察2个连贯的请求，来请求同一个图片，你会在Fiddler中发现：在第一个本地缓存版本中，服务器返回一个含有ETAG的文件，和一个含有最后修改日期的文件，在这个第一次的请求会话中，一个本地的缓存版本已经可以使用了。这样一来，一个有条件的请求就被创建出来。然后你再次请求这个图片的时候，他就就会响应一个本地缓存的文件，当然前提是第一次缓存的图片的ETAG值或者If- Modified-Since 值跟服务器上匹配的话，服务器就响应一个304给客户端。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Session #1</span><br><span class=\"line\"></span><br><span class=\"line\">GET /images/banner.jpg HTTP/1.1</span><br><span class=\"line\"></span><br><span class=\"line\">Host: www.bayden.com</span><br><span class=\"line\"></span><br><span class=\"line\">HTTP/1.1 200 OK</span><br><span class=\"line\"></span><br><span class=\"line\">Date: Tue, 08 Mar 2006 00:32:46 GMT</span><br><span class=\"line\"></span><br><span class=\"line\">Content-Length: 6171</span><br><span class=\"line\"></span><br><span class=\"line\">Content-Type: image/jpeg</span><br><span class=\"line\"></span><br><span class=\"line\">ETag: &quot;40c7f76e8d30c31:2fe20&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">Last-Modified: Thu, 12 Jun 2003 02:50:50 GMT</span><br><span class=\"line\"></span><br><span class=\"line\">Session #2</span><br><span class=\"line\"></span><br><span class=\"line\">GET /images/banner.jpg HTTP/1.1</span><br><span class=\"line\"></span><br><span class=\"line\">If-Modified-Since: Thu, 12 Jun 2003 02:50:50 GMT</span><br><span class=\"line\"></span><br><span class=\"line\">If-None-Match: &quot;40c7f76e8d30c31:2fe20&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">Host: www.bayden.com</span><br><span class=\"line\"></span><br><span class=\"line\">HTTP/1.1 304 Not Modified</span><br></pre></td></tr></table></figure>\n\n\n\n<p>因为一个HTTP304响应仅仅包含头，没有body,所有它在穿越互联网的时候要比携带了资源的快很多，尽管如此，HTTP&#x2F;304响应需要一个服务器的往返，但是通过细心的设置响应头，web程序员可以消除这种因素，甚至是有条件的请求。</p>\n<h3 id=\"缓存相关响应头\"><a href=\"#缓存相关响应头\" class=\"headerlink\" title=\"缓存相关响应头\"></a>缓存相关响应头</h3><p>通常缓存机制是由响应头来控制的。HTTP规范描述了Header控制缓存，The optional Cache-Control，Expires（过期）。</p>\n<p>Expires头包含一个绝对的日期，当超过此日期，它将不会被考虑更新了。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Table 2. Common Cache-Control Headers</span><br><span class=\"line\"></span><br><span class=\"line\">Value</span><br><span class=\"line\"></span><br><span class=\"line\">Meaning</span><br><span class=\"line\"></span><br><span class=\"line\">public</span><br><span class=\"line\"></span><br><span class=\"line\">The response may be stored in any cache, including caches shared among many users.</span><br><span class=\"line\"></span><br><span class=\"line\">private</span><br><span class=\"line\"></span><br><span class=\"line\">The response may only be stored in a private cache used by a single user.</span><br><span class=\"line\"></span><br><span class=\"line\">no-cache</span><br><span class=\"line\"></span><br><span class=\"line\">The response should not be reused to satisfy future requests.</span><br><span class=\"line\"></span><br><span class=\"line\">no-store</span><br><span class=\"line\"></span><br><span class=\"line\">The response should not be reused to satisfy future requests, and should not be written to disk. This is primarily used as a security measure for sensitive responses.</span><br><span class=\"line\"></span><br><span class=\"line\">max-age=#seconds</span><br><span class=\"line\"></span><br><span class=\"line\">The response may be reused to satisfy future requests within a certain number of seconds.</span><br><span class=\"line\"></span><br><span class=\"line\">must-revalidate</span><br><span class=\"line\"></span><br><span class=\"line\">The response may be reused to satisfy future requests, but the origin server should first be contacted to verify that the response is still fresh.</span><br><span class=\"line\"></span><br><span class=\"line\">Cache-Control头的参数设置：</span><br><span class=\"line\"></span><br><span class=\"line\">Public 响应会被缓存，并且在多用户间共享。</span><br><span class=\"line\"></span><br><span class=\"line\">Private 响应只能够作为私有的缓存，不能再用户间共享。</span><br><span class=\"line\"></span><br><span class=\"line\">No-cache 响应不会被缓存</span><br><span class=\"line\"></span><br><span class=\"line\">No-store 响应不会被缓存，并且不会被写入到客户端的磁盘里，这也是基于安全考虑的某些敏感的响应才会使用这个。</span><br><span class=\"line\"></span><br><span class=\"line\">Max-age=#seconds 响应将会某个指定的秒数内缓存，一旦时间过了，就不会被缓存。</span><br><span class=\"line\"></span><br><span class=\"line\">Must-revalidate 响应会被重用来满足接下来的请求，但是它必须到服务器端去验证它是不是仍然是最新的。</span><br></pre></td></tr></table></figure>\n\n<p>注意：</p>\n<p>如果你要想在iis中配置缓存，请参阅温软的知识技术文章：</p>\n<p>· <a href=\"http://support.microsoft.com/default.aspx?scid=kb;en-us;247404\">How to Modify the Cache-Control HTTP Header When You Use IIS</a>.</p>\n<p>你可以学习更多关于在asp.net中使用缓存的知识文章：</p>\n<p>· <a href=\"http://support.microsoft.com/default.aspx?scid=kb;en-us;323290\">How To Cache in ASP.NET by Using Visual C# .NET</a>.</p>\n<p>如果你发现你经常在你的网站上更新文件，但是并没有更改文件名字，那你就必须要非常小心地设置你的缓存生存时间。例如：如果你要一个thisyear.gif图片文件显示当前的年份在网站上，你需要保证这个缓存过期时间不能超过一天，否则一个用户在12月31号访问你的网站的时候，在1月1号就不能显示正确的日期。</p>\n<p>由于某些原因，服务器可能会设置：Progma：no-cache 头，Cache-control:no-cache</p>\n<p>Header中的参数：Vary 是一个缓存信号，Vary：User-Agent表示缓存当前的响应，但是仅限于当发送同样的User-Agent 头的时候。指令 Vary：* 就相当于Cache-Control：no-Cache。</p>\n<p>Vary就相当于asp.net中的缓存的参数一样，意思是根据什么来缓存，如果要是知道asp.net的缓存的使用方法，就很容易明白这个参数的意思。</p>\n<p>使用HTTP会话列表，Fiddler用户可以看到在页面里包含的ＨＴＴＰ缓存头。</p>\n<h3 id=\"Fiddler会话列表\"><a href=\"#Fiddler会话列表\" class=\"headerlink\" title=\"Fiddler会话列表\"></a>Fiddler会话列表</h3><p>如果响应不包含Ｅｘｐｉｒｅｓ或者Ｃａｃｈｅ－Ｃｏｎｔｒｏｌ，那么客户端就会被迫作为一个有条件的请求，来保证所有的资源都是最新的。</p>\n<p>有条件的请求和ＷｉｎＩｎｅｔＣａｃｈｅ</p>\n<p>ＩＥ通过Ｍｉｃｒｏｓｏｆｔ　ｗｉｎｄｏｗｓ　Ｉｎｔｅｒｎｅｔ　Ｓｅｒｖｉｃｅｓ来最大程度的利用缓存服务。ＷｉｎＩｎｅｔ允许用户配置缓存的大小和行为，设置缓存进行如下操作：</p>\n<p>１　打开ＩＥ，</p>\n<p>２　工具选项，选择Ｉｎtｅｒｎｅｔ选项，在一般子选项中，临时文件夹内，点击设置</p>\n<p>下图就是选村的四种设置：</p>\n<p>标记性能问题：</p>\n<p>你可以使用Ｆｉｄｄｌｅｒ的自定义规则来标记某些你需要的，比如如果某个响应大于２５ＫＢ，你可以把当前的Ｓｅｓｓｉｏｎ标记为红色，更加醒目。以下代码都是在OnBeforeResponse事件中：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Flag files over 25KB</span><br><span class=\"line\"></span><br><span class=\"line\">   if (oSession.responseBodyBytes.length &gt; 25000)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">      oSession\\[&quot;ui-color&quot;\\] = &quot;red&quot;;</span><br><span class=\"line\">    </span><br><span class=\"line\">      oSession\\[&quot;ui-bold&quot;\\] = &quot;true&quot;;</span><br><span class=\"line\">    </span><br><span class=\"line\">      oSession\\[&quot;ui-customcolumn&quot;\\] = &quot;Large file&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">同样，你也可以标记响应并不指示缓存信息。</span><br><span class=\"line\"></span><br><span class=\"line\">   // Mark files which do not have caching information</span><br><span class=\"line\"></span><br><span class=\"line\">if (!oSession.oResponse.headers.Exists(&quot;Expires&quot;) &amp;&amp;</span><br><span class=\"line\"></span><br><span class=\"line\">!oSession.oResponse.headers.Exists(&quot;Cache-Control&quot;))&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">oSession\\[&quot;ui-color&quot;\\] = &quot;purple&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">      oSession\\[&quot;ui-bold&quot;\\] = &quot;true&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"介绍HTTP压缩\"><a href=\"#介绍HTTP压缩\" class=\"headerlink\" title=\"介绍HTTP压缩\"></a>介绍HTTP压缩</h2><p>所有的目前流行的ＷＥＢ服务器和浏览器都提供ＨＴＴＰ压缩支持。ＨＴＴＰ压缩可以非常显著地降低客户端和服务器端的通讯量。节省超过５０％的ＨＴＭＬ，ＸＭＬ，ＣＳＳ，ＪＳ等文件。一个浏览器发送一个信号给服务器，他可以介绍ＨＴＴＰ压缩过的内容，并且会把客户端所支持的压缩类型放在请求的Ｈｅａｄｅｒ中，例如：考虑如下的请求：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET / HTTP/1.1</span><br><span class=\"line\"></span><br><span class=\"line\">Accept: \\*/\\*</span><br><span class=\"line\"></span><br><span class=\"line\">Accept-Language: en-us</span><br><span class=\"line\"></span><br><span class=\"line\">Accept-Encoding: gzip, deflate</span><br><span class=\"line\"></span><br><span class=\"line\">User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 1.1.4322)</span><br><span class=\"line\"></span><br><span class=\"line\">Host: search.msn.com</span><br><span class=\"line\"></span><br><span class=\"line\">这个　Ａｃｃｅｐｔ－Ｅｎｃｏｄｉｎｇ　头表明ＩＥ将愿意接受ＧＺＩＰ格式的和ＤＥＦＬＡＴＥ格式的压缩响应。</span><br><span class=\"line\"></span><br><span class=\"line\">相应的响应如下：</span><br><span class=\"line\"></span><br><span class=\"line\">HTTP/1.1 200 OK</span><br><span class=\"line\"></span><br><span class=\"line\">Content-Type: text/html; charset=utf-8</span><br><span class=\"line\"></span><br><span class=\"line\">Server: Microsoft-IIS/6.0 --Microsoft-HTTPAPI/1.0</span><br><span class=\"line\"></span><br><span class=\"line\">X-Powered-By: ASP.NET</span><br><span class=\"line\"></span><br><span class=\"line\">Vary: Accept-Encoding</span><br><span class=\"line\"></span><br><span class=\"line\">Content-Encoding: gzip</span><br><span class=\"line\"></span><br><span class=\"line\">Date: Tue, 15 Feb 2006 09:14:36 GMT</span><br><span class=\"line\"></span><br><span class=\"line\">Content-Length: 1277</span><br><span class=\"line\"></span><br><span class=\"line\">Connection: close</span><br><span class=\"line\"></span><br><span class=\"line\">Cache-Control: private, max-age=3600</span><br></pre></td></tr></table></figure>\n\n<p>你可以使用Ｆｉｄｄｌｅｒ来解压缩这些数据。实验表明，使用ＨＴＴＰ压缩能大量减少数据往返，一个普通的ＣＳＳ文件甚至能减少８０％！当然压缩是以牺牲ＣＰＵ性能为代价的。特别是压缩动态文件，但是一般的权宜之策是压缩例如ＪＳ，ＣＳＳ等静态文件，因为他们在第一次压缩后，就会被存储在服务器上，如果要压缩ａｓｐ．ｎｅｔ动态文件，一定要有个权衡才行</p>\n<p>如果您现在还是不满足您的程序优化，那么你还可以参看这篇文章，</p>\n<p><a href=\"http://msdn.microsoft.com/msdnmag/issues/05/01/ASPNETPerformance/default.aspx\">Ten Tips for Writing High-Performance Web Applications</a></p>","categories":[{"name":"Javascript","path":"api/categories/Javascript.json"}],"tags":[{"name":"Javascript","path":"api/tags/Javascript.json"},{"name":"JS","path":"api/tags/JS.json"},{"name":"抓包","path":"api/tags/抓包.json"},{"name":"HTTP","path":"api/tags/HTTP.json"},{"name":"Fiddler","path":"api/tags/Fiddler.json"}]}
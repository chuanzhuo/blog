{"title":"ajax和Java session监听-CarlZeng","slug":"ajax和Java-session监听-CarlZeng","date":"2008-10-10T02:02:00.000Z","updated":"2023-10-02T02:27:28.914Z","comments":true,"path":"api/articles/ajax和Java-session监听-CarlZeng.json","excerpt":"Session监听嘛，没什么好解释的，java提供了很灵活的事件机制来监听session，可以监听session的创建和销毁，监控session 所携带数据的创建、变化和销毁，可以监听session的锐化和钝化（了解对象序列化的兄弟应该知道这个），其他的平台是个什么情况我不太清楚，估计也差不多吧。如果能够对所有客户的session进行监控，就不用再去操作麻烦而危险的Application了。---...","covers":null,"content":"<p>Session监听嘛，没什么好解释的，java提供了很灵活的事件机制来监听session，可以监听session的创建和销毁，监控session 所携带数据的创建、变化和销毁，可以监听session的锐化和钝化（了解对象序列化的兄弟应该知道这个），其他的平台是个什么情况我不太清楚，估计也差不多吧。如果能够对所有客户的session进行监控，就不用再去操作麻烦而危险的Application了。—…</p>\n<!-- more -->\n<p>Session监听嘛，没什么好解释的，java提供了很灵活的事件机制来监听session，可以监听session的创建和销毁，监控session 所携带数据的创建、变化和销毁，可以监听session的锐化和钝化（了解对象序列化的兄弟应该知道这个），其他的平台是个什么情况我不太清楚，估计也差不多吧。如果能够对所有客户的session进行监控，就不用再去操作麻烦而危险的Application了。</p>\n<p>-—-</p>\n<p>一、 session监听</p>\n<p>　　servlet中对session的监听有很多接口，功能很灵活，最常用的是监听Session和Attribute。这里要澄清一下概念，servlet中的session监听和Attribute监听含义有差别，session监听指的不是我们一般所理解的放置一个session或者销毁一个session，这是Attribute监听的功能，因为servlet中放置session的语法是 session.setAttribute(“session名”,要放入的对象)。而session监听，监听的是HTTP连接，只要有用户与 server连接，就算连接的是一个空白的jsp页面，也会触发session事件，所以此处的session实际上指的是connection，用来统计当前在线用户数最合适了。不知道我说清楚了没有。下面分别讲解这两种监听方式。<br>　　1、 session监听</p>\n<p>　　首先编写一个session监听类，实作HttpSessionListener接口，它的作用是计算当前有多少个在线用户：</p>\n<p>package org.bromon.test;</p>\n<p>import javax.servlet.*;<br>import javax.servlet.http.*;</p>\n<p>public class SessionCount implements HttpSessionListener<br>{<br>private static int count&#x3D;0;</p>\n<p>public void sessionCreated(HttpSessionEvent se)<br>{<br>count++;<br>System.out.println(“session创建：”+new java.util.Date());<br>}</p>\n<p>public void sessionDestroyed(HttpSessionEvent se)<br>{<br>count–;<br>System.out.println(“session销毁:”+new java.util.Date());<br>}</p>\n<p>public static int getCount()<br>{<br>return(count);<br>}<br>}</p>\n<p>　　怎么样，是不是一目了然？count被定义为static，是因为要保证整个系统只有这一个count。如果你实在不放心，可以把它写成一个单例类。</p>\n<p>　　然后在web.xml中声明这个监听器：</p>\n<listener>  \n<listener-class>  \norg.bromon.test.SessionCount  \n</listener-class>  \n</listener>\n\n  \n<p>　　编写一个测试页面test.jsp，内容是获得count：</p>\n<p>&lt;%<br>int count&#x3D;org.bromon.test.SessionCount.getCount();<br>out.println(count);<br>%&gt;</p>\n<p>　　需要注意的是，这里根本不涉及任何session的操作。重启动App server，试着连接test.jsp，可以看到监听器已经开始工作。<br>　2、 Attribute监听</p>\n<p>　　作为一个站内消息系统，肯定要获得所有登陆者的ID，才有可能互发消息。这就涉及Attribute监听。假设我们写了个用户登陆的模块，用户通过身份验证之后会产生一个session，保存它的相关信息，比如：</p>\n<p>&#x2F;&#x2F;check.jsp<br>&lt;%<br>String name&#x3D;request.getParameter(“name”);<br>Name&#x3D;new String(name.getBytes(“ISO8859-1”));<br>session.setAttribute(“user”,name);<br>%&gt;</p>\n<p>　　做过jsp的兄弟应该对这段代码再熟悉不过了，下面写个监听器来监听用户登陆，把所有用户的ID保存到一个List当中，这个监听器实作HttpSessionAttributeListener接口：</p>\n<p>package org.bromon.test;</p>\n<p>import javax.servlet.*;<br>import javax.servlet.http.*;<br>import java.util.*;</p>\n<p>public class OnlineList implements HttpSessionAttributeListener<br>{<br>private static List list&#x3D;new ArrayList();</p>\n<p>public void attributeAdded(HttpSessionBindingEvent se)</p>\n<p>{<br>if(“user”.equals(se.getName()))<br>{<br>list.add(se.getValue());<br>}<br>}</p>\n<p>public void attributeRemoved(HttpSessionBindingEvent se)<br>{<br>if(“user”.equals(se.getName()))<br>{<br>list.remove(se.getValue());<br>}<br>}</p>\n<p>public void attributeReplaced(HttpSessionBindingEvent se){}</p>\n<p>public static List getList()<br>{<br>return(list);<br>}<br>}</p>\n<p>　　写个简单的jsp来得到用户列表：</p>\n<p>&ly;%<br>java.util.List list&#x3D;org.bromon.test.OnlineList.getList();<br>out.println(“共有”+list.size()+”名用户已登陆：”);<br>for(int I&#x3D;0;I&lt;lise.size();i++)<br>{<br>out.println(list.get(i));<br>}<br>%&gt;</p>\n<p>　　也许你说，这有什么神奇呢，监听session而已，不着急，看看xmlhttp。<br>二、 XMLHTTP</p>\n<p>　　XMLHTTP的用处很多，这里只说我们需要的，就是无刷新的与server通信，看这段代码：</p>\n<script language=\"javascript\">  \nxml = new ActiveXObject(\"Microsoft.XMLHTTP\");  \nvar post=\" \";//构造要携带的数据  \nxml.open(\"POST\",\"http://localhost:7001/TestWL/index.jsp\",false);//使用POST方法打开一个到服务器的连接，以异步方式通信  \nxml.setrequestheader(\"content-length\",post.length);  \nxml.setrequestheader(\"content-type\",\"application/x-www-form-urlencoded\");  \nxml.send(post);//发送数据  \nvar res = xml.responseText;//接收服务器返回的数据  \ndocument.write(res);  \n</script>\n\n<p>　　豁然开朗，这段代码就是打开一个HTTP连接，以标准的HTTP格式传递数据，如果你喜欢，可以用XML的格式来传递。更改一下xml 对象的构造方式就可以兼容Mozilla和Netscape。下面来写一个轮询，每隔一段时间刷新一次用户列表，当然，是不需要刷新页面的：</p>\n<html>  \n<head><title>探测器</title>  \n<script language=\"javascript\">  \nfunction detect()  \n{  \nxml = new ActiveXObject(\"Microsoft.XMLHTTP\");  \nvar post=\" \";//构造要携带的数据  \nxml.open(\"POST\",\"http://localhost:7001/TestWL/index.jsp\",false);//使用POST方法打开一个到服务器的连接，以异步方式通信  \nxml.setrequestheader(\"content-length\",post.length);  \nxml.setrequestheader(\"content-type\",\"application/x-www-form-urlencoded\");  \nxml.send(post);//发送数据  \nvar res = xml.responseText;//接收服务器返回的数据  \nlist.innerText=res;  \nsetTimeout(\"detect()\",5000);//每隔5秒钟轮询一次  \n}  \n</script>  \n<body onload=\"detect()\">  \n<a id=\"list\"></a>  \n</body>  \n</html>\n\n  \n<p>　　这样的通信方式数据量很小，不用重新传递整个页面，5秒钟轮一次，普通PC也能承受较大的在线数。构造一个探测器来监听在线列表和消息，效果是很好的，即使你的客户坐在电脑前袖手旁观，键鼠都不碰一下，也能保证数据即时传递，页面也不会发生跳转和刷新。</p>\n<p>　　Session监听加上XMLHTTP通信</p>\n","more":"<p>Session监听嘛，没什么好解释的，java提供了很灵活的事件机制来监听session，可以监听session的创建和销毁，监控session 所携带数据的创建、变化和销毁，可以监听session的锐化和钝化（了解对象序列化的兄弟应该知道这个），其他的平台是个什么情况我不太清楚，估计也差不多吧。如果能够对所有客户的session进行监控，就不用再去操作麻烦而危险的Application了。—…</p>\n<!-- more -->\n<p>Session监听嘛，没什么好解释的，java提供了很灵活的事件机制来监听session，可以监听session的创建和销毁，监控session 所携带数据的创建、变化和销毁，可以监听session的锐化和钝化（了解对象序列化的兄弟应该知道这个），其他的平台是个什么情况我不太清楚，估计也差不多吧。如果能够对所有客户的session进行监控，就不用再去操作麻烦而危险的Application了。</p>\n<p>-—-</p>\n<p>一、 session监听</p>\n<p>　　servlet中对session的监听有很多接口，功能很灵活，最常用的是监听Session和Attribute。这里要澄清一下概念，servlet中的session监听和Attribute监听含义有差别，session监听指的不是我们一般所理解的放置一个session或者销毁一个session，这是Attribute监听的功能，因为servlet中放置session的语法是 session.setAttribute(“session名”,要放入的对象)。而session监听，监听的是HTTP连接，只要有用户与 server连接，就算连接的是一个空白的jsp页面，也会触发session事件，所以此处的session实际上指的是connection，用来统计当前在线用户数最合适了。不知道我说清楚了没有。下面分别讲解这两种监听方式。<br>　　1、 session监听</p>\n<p>　　首先编写一个session监听类，实作HttpSessionListener接口，它的作用是计算当前有多少个在线用户：</p>\n<p>package org.bromon.test;</p>\n<p>import javax.servlet.*;<br>import javax.servlet.http.*;</p>\n<p>public class SessionCount implements HttpSessionListener<br>{<br>private static int count&#x3D;0;</p>\n<p>public void sessionCreated(HttpSessionEvent se)<br>{<br>count++;<br>System.out.println(“session创建：”+new java.util.Date());<br>}</p>\n<p>public void sessionDestroyed(HttpSessionEvent se)<br>{<br>count–;<br>System.out.println(“session销毁:”+new java.util.Date());<br>}</p>\n<p>public static int getCount()<br>{<br>return(count);<br>}<br>}</p>\n<p>　　怎么样，是不是一目了然？count被定义为static，是因为要保证整个系统只有这一个count。如果你实在不放心，可以把它写成一个单例类。</p>\n<p>　　然后在web.xml中声明这个监听器：</p>\n<listener>  \n<listener-class>  \norg.bromon.test.SessionCount  \n</listener-class>  \n</listener>\n\n  \n<p>　　编写一个测试页面test.jsp，内容是获得count：</p>\n<p>&lt;%<br>int count&#x3D;org.bromon.test.SessionCount.getCount();<br>out.println(count);<br>%&gt;</p>\n<p>　　需要注意的是，这里根本不涉及任何session的操作。重启动App server，试着连接test.jsp，可以看到监听器已经开始工作。<br>　2、 Attribute监听</p>\n<p>　　作为一个站内消息系统，肯定要获得所有登陆者的ID，才有可能互发消息。这就涉及Attribute监听。假设我们写了个用户登陆的模块，用户通过身份验证之后会产生一个session，保存它的相关信息，比如：</p>\n<p>&#x2F;&#x2F;check.jsp<br>&lt;%<br>String name&#x3D;request.getParameter(“name”);<br>Name&#x3D;new String(name.getBytes(“ISO8859-1”));<br>session.setAttribute(“user”,name);<br>%&gt;</p>\n<p>　　做过jsp的兄弟应该对这段代码再熟悉不过了，下面写个监听器来监听用户登陆，把所有用户的ID保存到一个List当中，这个监听器实作HttpSessionAttributeListener接口：</p>\n<p>package org.bromon.test;</p>\n<p>import javax.servlet.*;<br>import javax.servlet.http.*;<br>import java.util.*;</p>\n<p>public class OnlineList implements HttpSessionAttributeListener<br>{<br>private static List list&#x3D;new ArrayList();</p>\n<p>public void attributeAdded(HttpSessionBindingEvent se)</p>\n<p>{<br>if(“user”.equals(se.getName()))<br>{<br>list.add(se.getValue());<br>}<br>}</p>\n<p>public void attributeRemoved(HttpSessionBindingEvent se)<br>{<br>if(“user”.equals(se.getName()))<br>{<br>list.remove(se.getValue());<br>}<br>}</p>\n<p>public void attributeReplaced(HttpSessionBindingEvent se){}</p>\n<p>public static List getList()<br>{<br>return(list);<br>}<br>}</p>\n<p>　　写个简单的jsp来得到用户列表：</p>\n<p>&ly;%<br>java.util.List list&#x3D;org.bromon.test.OnlineList.getList();<br>out.println(“共有”+list.size()+”名用户已登陆：”);<br>for(int I&#x3D;0;I&lt;lise.size();i++)<br>{<br>out.println(list.get(i));<br>}<br>%&gt;</p>\n<p>　　也许你说，这有什么神奇呢，监听session而已，不着急，看看xmlhttp。<br>二、 XMLHTTP</p>\n<p>　　XMLHTTP的用处很多，这里只说我们需要的，就是无刷新的与server通信，看这段代码：</p>\n<script language=\"javascript\">  \nxml = new ActiveXObject(\"Microsoft.XMLHTTP\");  \nvar post=\" \";//构造要携带的数据  \nxml.open(\"POST\",\"http://localhost:7001/TestWL/index.jsp\",false);//使用POST方法打开一个到服务器的连接，以异步方式通信  \nxml.setrequestheader(\"content-length\",post.length);  \nxml.setrequestheader(\"content-type\",\"application/x-www-form-urlencoded\");  \nxml.send(post);//发送数据  \nvar res = xml.responseText;//接收服务器返回的数据  \ndocument.write(res);  \n</script>\n\n<p>　　豁然开朗，这段代码就是打开一个HTTP连接，以标准的HTTP格式传递数据，如果你喜欢，可以用XML的格式来传递。更改一下xml 对象的构造方式就可以兼容Mozilla和Netscape。下面来写一个轮询，每隔一段时间刷新一次用户列表，当然，是不需要刷新页面的：</p>\n<html>  \n<head><title>探测器</title>  \n<script language=\"javascript\">  \nfunction detect()  \n{  \nxml = new ActiveXObject(\"Microsoft.XMLHTTP\");  \nvar post=\" \";//构造要携带的数据  \nxml.open(\"POST\",\"http://localhost:7001/TestWL/index.jsp\",false);//使用POST方法打开一个到服务器的连接，以异步方式通信  \nxml.setrequestheader(\"content-length\",post.length);  \nxml.setrequestheader(\"content-type\",\"application/x-www-form-urlencoded\");  \nxml.send(post);//发送数据  \nvar res = xml.responseText;//接收服务器返回的数据  \nlist.innerText=res;  \nsetTimeout(\"detect()\",5000);//每隔5秒钟轮询一次  \n}  \n</script>  \n<body onload=\"detect()\">  \n<a id=\"list\"></a>  \n</body>  \n</html>\n\n  \n<p>　　这样的通信方式数据量很小，不用重新传递整个页面，5秒钟轮一次，普通PC也能承受较大的在线数。构造一个探测器来监听在线列表和消息，效果是很好的，即使你的客户坐在电脑前袖手旁观，键鼠都不碰一下，也能保证数据即时传递，页面也不会发生跳转和刷新。</p>\n<p>　　Session监听加上XMLHTTP通信</p>\n","categories":[],"tags":[]}